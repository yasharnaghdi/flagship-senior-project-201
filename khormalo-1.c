    print()\n",
    "    \n",
    "    # 3. Race Strategy Analysis\n",
    "    print(\"3. Race Strategy Analysis\")\n",
    "    \n",
    "    if race_split_data is not None:\n",
    "        # Calculate pacing strategy\n",
    "        print(\"   Split Analysis:\")\n",
    "        for i, split in enumerate(race_split_data):\n",
    "            segment = f\"{i*50+1}-{(i+1)*50}m\"\n",
    "            print(f\"     {segment}: {split:.2f}s\")\n",
    "        \n",
    "        # Calculate first half vs second half\n",
    "        first_half = sum(race_split_data[:2])\n",
    "        second_half = sum(race_split_data[2:])\n",
    "        diff = second_half - first_half\n",
    "        diff_pct = (diff / first_half) * 100\n",
    "        \n",
    "        print(f\"\\n   First 100m: {first_half:.2f}s | Second 100m: {second_half:.2f}s\")\n",
    "        print(f\"   Difference: {diff:+.2f}s ({diff_pct:+.1f}%)\")\n",
    "        \n",
    "        # Identify pacing strategy\n",
    "        if diff < -1.0:\n",
    "            strategy = \"Negative Split (faster second half)\"\n",
    "        elif diff > 3.0:\n",
    "            strategy = \"Aggressive Start (much slower second half)\"\n",
    "        elif diff > 1.0:\n",
    "            strategy = \"Positive Split (moderately slower second half)\"\n",
    "        else:\n",
    "            strategy = \"Even Pace (balanced effort)\"\n",
    "        \n",
    "        print(f\"   Current Strategy: {strategy}\")\n",
    "        \n",
    "        # Calculate variability in pacing\n",
    "        cv = np.std(race_split_data) / np.mean(race_split_data) * 100\n",
    "        \n",
    "        print(f\"   Pacing Consistency: {cv:.1f}% variation between splits\")\n",
    "        \n",
    "        # Recommend optimal strategy based on swimmer profile\n",
    "        if swimmer['Years_Experience'] < 3:\n",
    "            recommended = \"Even Pace\"\n",
    "        else:\n",
    "            # Infer swimmer type based on stroke metrics\n",
    "            latest = performances.iloc[-1]\n",
    "            if latest['Stroke_Rate'] > 60 and latest['Stroke_Length'] < 1.8:\n",
    "                swimmer_type = \"Sprinter\"\n",
    "                recommended = \"Slight Positive Split\"\n",
    "            elif latest['Stroke_Rate'] < 50 and latest['Stroke_Length'] > 2.0:\n",
    "                swimmer_type = \"Distance\"\n",
    "                recommended = \"Negative Split\"\n",
    "            else:\n",
    "                swimmer_type = \"Balanced\"\n",
    "                recommended = \"Even Pace\"\n",
    "        \n",
    "        print(f\"\\n   Recommended Strategy: {recommended}\")\n",
    "    else:\n",
    "        print(\"   No race split data available for analysis\")\n",
    "    \n",
    "    print()\n",
    "    \n",
    "    # 4. Training Recommendations\n",
    "    print(\"4. Training Recommendations\")\n",
    "    \n",
    "    # Determine areas for improvement based on performance data\n",
    "    if not performances.empty:\n",
    "        latest = performances.iloc[-1]\n",
    "        \n",
    "        # Determine swimmer type (simplified)\n",
    "        if latest['Stroke_Rate'] > 60 and latest['Stroke_Length'] < 1.8:\n",
    "            swimmer_type = \"Sprinter\"\n",
    "        elif latest['Stroke_Rate'] < 50 and latest['Stroke_Length'] > 2.0:\n",
    "            swimmer_type = \"Distance\"\n",
    "        else:\n",
    "            swimmer_type = \"Balanced\"\n",
    "        \n",
    "        print(f\"   Swimmer Profile: {swimmer_type} Type\")\n",
    "        \n",
    "        # Identify areas for improvement\n",
    "        areas = []\n",
    "        \n",
    "        # Check stroke length\n",
    "        if swimmer_type == \"Sprinter\" and latest['Stroke_Length'] < 1.7:\n",
    "            areas.append((\"Stroke Length\", \"Low\", \"Increase distance per stroke through better catch and pull\"))\n",
    "        elif swimmer_type == \"Distance\" and latest['Stroke_Length'] < 1.9:\n",
    "            areas.append((\"Stroke Length\", \"Low\", \"Work on body position and stroke extension\"))\n",
    "        \n",
    "        # Check stroke rate\n",
    "        if swimmer_type == \"Sprinter\" and latest['Stroke_Rate'] < 55:\n",
    "            areas.append((\"Stroke Rate\", \"Low\", \"Develop faster turnover with sprint-specific drills\"))\n",
    "        elif swimmer_type == \"Distance\" and latest['Stroke_Rate'] > 60:\n",
    "            areas.append((\"Stroke Rate\", \"High\", \"Focus on stroke efficiency rather than turnover\"))\n",
    "        \n",
    "        # Check efficiency\n",
    "        if latest['Stroke_Index'] < 1.5:\n",
    "            areas.append((\"Efficiency\", \"Low\", \"Technique refinement should be the primary focus\"))\n",
    "        \n",
    "        # Display recommendations\n",
    "        print(\"\\n   Areas for Improvement:\")\n",
    "        if areas:\n",
    "            for area, status, recommendation in areas:\n",
    "                print(f\"     → {area} ({status}): {recommendation}\")\n",
    "        else:\n",
    "            print(\"     → No specific technical concerns identified\")\n",
    "        \n",
    "        # Recommend training focus\n",
    "        print(\"\\n   Recommended Training Focus:\")\n",
    "        \n",
    "        if any(area[0] == \"Efficiency\" and area[1] == \"Low\" for area in areas):\n",
    "            print(\"     Primary: Technique refinement\")\n",
    "            print(\"     Secondary: Endurance development\")\n",
    "            \n",
    "            # Sample training set\n",
    "            print(\"\\n   Sample Technique-Focused Training Set:\")\n",
    "            technique_set = generate_training_set(\n",
    "                swimmer_type=swimmer_type,\n",
    "                focus_area=\"Technique\",\n",
    "                base_time_100m=latest['Time'],\n",
    "                total_distance=1500\n",
    "            )\n",
    "            display(technique_set.head(5))\n",
    "            print(\"     ... (continued)\")\n",
    "            \n",
    "        elif swimmer_type == \"Sprinter\":\n",
    "            print(\"     Primary: Speed development\")\n",
    "            print(\"     Secondary: Race-specific endurance\")\n",
    "            \n",
    "            # Sample training set\n",
    "            print(\"\\n   Sample Speed-Focused Training Set:\")\n",
    "            speed_set = generate_training_set(\n",
    "                swimmer_type=\"Sprinter\",\n",
    "                focus_area=\"Speed\",\n",
    "                base_time_100m=latest['Time'],\n",
    "                total_distance=1200\n",
    "            )\n",
    "            display(speed_set.head(5))\n",
    "            print(\"     ... (continued)\")\n",
    "            \n",
    "        elif swimmer_type == \"Distance\":\n",
    "            print(\"     Primary: Aerobic development\")\n",
    "            print(\"     Secondary: Race pace control\")\n",
    "            \n",
    "            # Sample training set\n",
    "            print(\"\\n   Sample Endurance-Focused Training Set:\")\n",
    "            endurance_set = generate_training_set(\n",
    "                swimmer_type=\"Distance\",\n",
    "                focus_area=\"Endurance\",\n",
    "                base_time_100m=latest['Time'],\n",
    "                total_distance=2000\n",
    "            )\n",
    "            display(endurance_set.head(5))\n",
    "            print(\"     ... (continued)\")\n",
    "        else:\n",
    "            print(\"     Primary: Balanced approach with technique emphasis\")\n",
    "            print(\"     Secondary: Race-specific preparation\")\n",
    "            \n",
    "            # Sample training set\n",
    "            print(\"\\n   Sample Race-Focused Training Set:\")\n",
    "            race_set = generate_training_set(\n",
    "                swimmer_type=\"Balanced\",\n",
    "                focus_area=\"Race_Pace\",\n",
    "                base_time_100m=latest['Time'],\n",
    "                total_distance=1800\n",
    "            )\n",
    "            display(race_set.head(5))\n",
    "            print(\"     ... (continued)\")\n",
    "    else:\n",
    "        print(\"   Insufficient data for training recommendations\")\n",
    "    \n",
    "    print(\"\\n\" + \"-\" * 80)\n",
    "    print(\"Analysis Complete\")\n",
    "\n",
    "# Example: Perform a comprehensive analysis on a swimmer\n",
    "# Include race split data for 200m freestyle (50m splits)\n",
    "race_splits = [28.5, 30.2, 31.0, 30.5]\n",
    "\n",
    "# Analyze swimmer with ID 3\n",
    "comprehensive_swimmer_analysis(\n",
    "    swimmer_id=3,\n",
    "    swimmer_db=swimmers_db,\n",
    "    performance_db=performances_db,\n",
    "    race_split_data=race_splits\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3.6 Exercise: Apply Comprehensive Analysis to Your Swimmers\n",
    "\n",
    "Now it's your turn to apply the comprehensive analysis to your own swimmers. Use the framework and tools we've developed to analyze performance data, race strategy, and develop tailored training recommendations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise template for your own analysis\n",
    "\n",
    "# Step 1: Create data for your swimmer\n",
    "# my_swimmer = {\n",
    "#     'SwimmerID': 100,\n",
    "#     'Name': 'Your Swimmer',\n",
    "#     'Age': 15,\n",
    "#     'Gender': 'F',  # or 'M'\n",
    "#     'Years_Experience': 5\n",
    "# }\n",
    "\n",
    "# Step 2: Create performance data\n",
    "# my_performances = [\n",
    "#     {'AssessmentID': 1, 'Time': 65.2, 'Stroke_Count': 35, 'Velocity': 1.53, 'Stroke_Length': 1.71, 'Stroke_Rate': 53.7, 'Stroke_Index': 2.62},\n",
    "#     {'AssessmentID': 2, 'Time': 63.8, 'Stroke_Count': 34, 'Velocity': 1.57, 'Stroke_Length': 1.76, 'Stroke_Rate': 53.3, 'Stroke_Index': 2.76},\n",
    "#     {'AssessmentID': 3, 'Time': 62.5, 'Stroke_Count': 33, 'Velocity': 1.60, 'Stroke_Length': 1.82, 'Stroke_Rate': 52.8, 'Stroke_Index': 2.91},\n",
    "#     {'AssessmentID': 4, 'Time': 61.0, 'Stroke_Count': 32, 'Velocity': 1.64, 'Stroke_Length': 1.88, 'Stroke_Rate': 52.5, 'Stroke_Index': 3.08}\n",
    "# ]\n",
    "\n",
    "# Step 3: Convert to DataFrames\n",
    "# my_swimmer_df = pd.DataFrame([my_swimmer])\n",
    "# my_performance_df = pd.DataFrame(my_performances)\n",
    "\n",
    "# Step 4: Add race split data if available (e.g., 200m freestyle)\n",
    "# my_race_splits = [28.0, 30.0, 31.2, 30.8]  # Four 50m splits\n",
    "\n",
    "# Step 5: Run the comprehensive analysis\n",
    "# comprehensive_swimmer_analysis(\n",
    "#     swimmer_id=100,\n",
    "#     swimmer_db=my_swimmer_df,\n",
    "#     performance_db=my_performance_df,\n",
    "#     race_split_data=my_race_splits\n",
    "# )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Day 3 Summary and Key Takeaways\n",
    "\n",
    "Today we've explored advanced analytics and practical applications for swimming coaches:\n",
    "\n",
    "1. **Interactive Dashboards**:\n",
    "   - Creating visual performance dashboards\n",
    "   - Using interactive tools to analyze multiple metrics\n",
    "   - Sharing clear visual insights with swimmers\n",
    "\n",
    "2. **Predictive Models**:\n",
    "   - Using machine learning to predict performance improvements\n",
    "   - Identifying key factors that affect development\n",
    "   - Creating data-driven training recommendations\n",
    "\n",
    "3. **Race Strategy Analysis**:\n",
    "   - Quantifying the impact of pacing strategies\n",
    "   - Matching strategies to swimmer profiles\n",
    "   - Optimizing race execution for different events\n",
    "\n",
    "4. **Custom Training Design**:\n",
    "   - Creating tailored training sets based on data\n",
    "   - Adapting workouts to swimmer type and focus areas\n",
    "   - Implementing evidence-based training progressions\n",
    "\n",
    "5. **Comprehensive Swimmer Analysis**:\n",
    "   - Integrating multiple data sources for complete insights\n",
    "   - Identifying specific areas for improvement\n",
    "   - Developing targeted training interventions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Workshop Conclusion\n",
    "\n",
    "Congratulations on completing the 3-Day Technical Analysis Workshop for Swimming Coaches! Over these three days, you've learned to:\n",
    "\n",
    "- **Day 1**: Analyze key performance metrics, create swimmer profiles, and examine race patterns\n",
    "- **Day 2**: Use video analysis to evaluate technique, compare stroke mechanics, and analyze rhythm\n",
    "- **Day 3**: Create interactive dashboards, develop predictive models, and design custom training programs\n",
    "\n",
    "## Next Steps\n",
    "\n",
    "To continue your development as a data-informed swimming coach:\n",
    "\n",
    "1. **Implement Regular Testing**\n",
    "   - Establish a consistent testing protocol for your swimmers\n",
    "   - Track metrics over time to identify patterns and improvements\n",
    "   - Use the analysis techniques learned to guide your coaching decisions\n",
    "\n",
    "2. **Expand Your Technical Toolkit**\n",
    "   - Experiment with video analysis using different angles and perspectives\n",
    "   - Try creating custom dashboards for your team or individual swimmers\n",
    "   - Apply race analysis to different events and distances\n",
    "\n",
    "3. **Share Your Insights**\n",
    "   - Use data visualizations to communicate with swimmers and parents\n",
    "   - Collaborate with other coaches to compare analysis approaches\n",
    "   - Consider publishing your findings to contribute to coaching knowledge\n",
    "\n",
    "4. **Continue Learning**\n",
    "   - Stay updated on new research in swimming biomechanics\n",
    "   - Explore additional data analysis techniques and tools\n",
    "   - Connect theory with practical application in your coaching\n",
    "\n",
    "Remember that data and analytics are tools to enhance your coaching, not replace your expertise and intuition. The most effective coaches combine objective analysis with experienced observation and interpersonal skills.\n",
    "\n",
    "Thank you for participating in this workshop. We hope these tools and techniques help you take your coaching to the next level!"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}    print(f\"Predicted Improvement (Linear Regression): {lr_improvement:.2f} seconds\")\n",
    "    print(f\"Predicted Improvement (Random Forest): {rf_improvement:.2f} seconds\")\n",
    "    print(f\"Average Predicted Improvement: {avg_improvement:.2f} seconds\")\n",
    "    \n",
    "    return avg_improvement\n",
    "\n",
    "# Example: Predict improvement for a new swimmer\n",
    "print(\"Predicted Improvement for a New Swimmer:\")\n",
    "predict_improvement(\n",
    "    age=14,\n",
    "    height=165,\n",
    "    experience=3,\n",
    "    weekly_hours=10,\n",
    "    strength_training=1,\n",
    "    nutrition=7,\n",
    "    flexibility=8,\n",
    "    gender='F'\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Training Recommendations Based on Predictive Models\n",
    "\n",
    "Now, let's use our model to generate training recommendations for swimmers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_training_recommendations(age, height, experience, weekly_hours, strength_training, nutrition, flexibility, gender):\n",
    "    \"\"\"Generate training recommendations based on model insights\"\"\"\n",
    "    # Create a base features list\n",
    "    base_improvement = predict_improvement(\n",
    "        age, height, experience, weekly_hours, strength_training, nutrition, flexibility, gender\n",
    "    )\n",
    "    \n",
    "    # Try modifying different features to see which changes would have the biggest impact\n",
    "    improvements = []\n",
    "    \n",
    "    # Increase weekly hours by 2\n",
    "    if weekly_hours < 18:\n",
    "        improved_hours = predict_improvement(\n",
    "            age, height, experience, weekly_hours + 2, strength_training, nutrition, flexibility, gender\n",
    "        )\n",
    "        improvements.append((\"Increase weekly training hours by 2\", improved_hours - base_improvement))\n",
    "    \n",
    "    # Add strength training\n",
    "    if strength_training == 0:\n",
    "        with_strength = predict_improvement(\n",
    "            age, height, experience, weekly_hours, 1, nutrition, flexibility, gender\n",
    "        )\n",
    "        improvements.append((\"Add strength training\", with_strength - base_improvement))\n",
    "    \n",
    "    # Improve nutrition\n",
    "    if nutrition < 9:\n",
    "        better_nutrition = predict_improvement(\n",
    "            age, height, experience, weekly_hours, strength_training, min(nutrition + 2, 10), flexibility, gender\n",
    "        )\n",
    "        improvements.append((\"Improve nutrition score\", better_nutrition - base_improvement))\n",
    "    \n",
    "    # Improve flexibility\n",
    "    if flexibility < 9:\n",
    "        better_flexibility = predict_improvement(\n",
    "            age, height, experience, weekly_hours, strength_training, nutrition, min(flexibility + 2, 10), gender\n",
    "        )\n",
    "        improvements.append((\"Improve flexibility\", better_flexibility - base_improvement))\n",
    "    \n",
    "    # Sort recommendations by impact\n",
    "    improvements.sort(key=lambda x: x[1], reverse=True)\n",
    "    \n",
    "    # Print recommendations\n",
    "    print(\"\\nRecommendations ranked by potential impact:\")\n",
    "    for i, (recommendation, impact) in enumerate(improvements, 1):\n",
    "        print(f\"{i}. {recommendation}: +{impact:.2f} seconds improvement\")\n",
    "    \n",
    "    # Provide age-specific recommendations\n",
    "    print(\"\\nAge-specific considerations:\")\n",
    "    if age < 14:\n",
    "        print(\"- Focus on technique development and building a strong aerobic base\")\n",
    "        print(\"- Avoid heavy strength training, use bodyweight exercises instead\")\n",
    "        print(\"- Maintain fun and variety in training to support long-term development\")\n",
    "    elif age < 16:\n",
    "        print(\"- Gradually introduce more structured training\")\n",
    "        print(\"- Begin building strength with proper technique emphasis\")\n",
    "        print(\"- Develop race strategies and pacing skills\")\n",
    "    else:\n",
    "        print(\"- Consider specialization in best events\")\n",
    "        print(\"- Periodized training approach with designated rest periods\")\n",
    "        print(\"- More advanced strength and conditioning program\")\n",
    "        \n",
    "# Example: Get training recommendations for our swimmer\n",
    "get_training_recommendations(\n",
    "    age=14,\n",
    "    height=165,\n",
    "    experience=3,\n",
    "    weekly_hours=10,\n",
    "    strength_training=1,\n",
    "    nutrition=7,\n",
    "    flexibility=8,\n",
    "    gender='F'\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3.3 Analyzing Race Strategy with Data\n",
    "\n",
    "Let's use data to optimize race strategy for different events and swimmer types."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create simulated race strategy data\n",
    "# These are 200m freestyle races with different pacing strategies\n",
    "\n",
    "race_strategies = pd.DataFrame({\n",
    "    'Strategy': [\n",
    "        'Even Pace', 'Even Pace', 'Even Pace', 'Even Pace', 'Even Pace',\n",
    "        'Fast Start', 'Fast Start', 'Fast Start', 'Fast Start', 'Fast Start',\n",
    "        'Negative Split', 'Negative Split', 'Negative Split', 'Negative Split', 'Negative Split',\n",
    "    ],\n",
    "    'Swimmer_Type': [\n",
    "        'Sprinter', 'Distance', 'Distance', 'Sprinter', 'Balanced',\n",
    "        'Sprinter', 'Sprinter', 'Distance', 'Distance', 'Balanced',\n",
    "        'Distance', 'Distance', 'Balanced', 'Sprinter', 'Balanced',\n",
    "    ]\n",
    "})\n",
    "\n",
    "# Add 50m split times\n",
    "# Base times for each swimmer type\n",
    "base_times = {'Sprinter': 27.0, 'Distance': 28.0, 'Balanced': 27.5}\n",
    "\n",
    "# Pacing factors for different strategies\n",
    "pacing = {\n",
    "    'Even Pace': [1.00, 1.00, 1.00, 1.00],\n",
    "    'Fast Start': [0.97, 1.00, 1.03, 1.05],\n",
    "    'Negative Split': [1.03, 1.01, 0.99, 0.97]\n",
    "}\n",
    "\n",
    "# Swimmer specific adjustments\n",
    "swimmer_adjustments = {\n",
    "    'Sprinter': {'Even Pace': 0.01, 'Fast Start': -0.01, 'Negative Split': 0.03},\n",
    "    'Distance': {'Even Pace': -0.01, 'Fast Start': 0.02, 'Negative Split': -0.02},\n",
    "    'Balanced': {'Even Pace': -0.01, 'Fast Start': 0.0, 'Negative Split': 0.0}\n",
    "}\n",
    "\n",
    "# Generate split times with some random variation\n",
    "np.random.seed(42)\n",
    "splits = []\n",
    "\n",
    "for i, row in race_strategies.iterrows():\n",
    "    strategy = row['Strategy']\n",
    "    swimmer_type = row['Swimmer_Type']\n",
    "    \n",
    "    # Get base time for this swimmer type\n",
    "    base_time = base_times[swimmer_type]\n",
    "    \n",
    "    # Get pacing factors for this strategy\n",
    "    pace_factors = pacing[strategy]\n",
    "    \n",
    "    # Apply swimmer-specific adjustment\n",
    "    adjustment = swimmer_adjustments[swimmer_type][strategy]\n",
    "    \n",
    "    # Generate splits\n",
    "    race_splits = []\n",
    "    for j, factor in enumerate(pace_factors):\n",
    "        # Apply strategy, adjustment, and some random variation\n",
    "        split_time = base_time * factor * (1 + adjustment) + np.random.normal(0, 0.1)\n",
    "        race_splits.append(split_time)\n",
    "    \n",
    "    splits.append(race_splits)\n",
    "\n",
    "# Add splits to dataframe\n",
    "race_strategies['Split_50m'] = [split[0] for split in splits]\n",
    "race_strategies['Split_100m'] = [split[1] for split in splits]\n",
    "race_strategies['Split_150m'] = [split[2] for split in splits]\n",
    "race_strategies['Split_200m'] = [split[3] for split in splits]\n",
    "\n",
    "# Calculate total time\n",
    "race_strategies['Total_Time'] = race_strategies['Split_50m'] + race_strategies['Split_100m'] + \\\n",
    "                               race_strategies['Split_150m'] + race_strategies['Split_200m']\n",
    "\n",
    "# Display the data\n",
    "race_strategies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Analyze race strategies by swimmer type\n",
    "strategy_analysis = race_strategies.groupby(['Swimmer_Type', 'Strategy'])['Total_Time'].mean().reset_index()\n",
    "strategy_analysis = strategy_analysis.sort_values(['Swimmer_Type', 'Total_Time'])\n",
    "\n",
    "# Visualize the results\n",
    "plt.figure(figsize=(10, 6))\n",
    "sns.barplot(x='Swimmer_Type', y='Total_Time', hue='Strategy', data=strategy_analysis)\n",
    "plt.title('Race Strategy Effectiveness by Swimmer Type')\n",
    "plt.ylabel('Average Time (seconds)')\n",
    "plt.grid(axis='y')\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Create a more detailed analysis\n",
    "print(\"Best Race Strategies by Swimmer Type:\")\n",
    "for swimmer_type in strategy_analysis['Swimmer_Type'].unique():\n",
    "    swimmer_data = strategy_analysis[strategy_analysis['Swimmer_Type'] == swimmer_type].sort_values('Total_Time')\n",
    "    best_strategy = swimmer_data.iloc[0]['Strategy']\n",
    "    worst_strategy = swimmer_data.iloc[-1]['Strategy']\n",
    "    time_diff = swimmer_data.iloc[-1]['Total_Time'] - swimmer_data.iloc[0]['Total_Time']\n",
    "    \n",
    "    print(f\"\\n{swimmer_type} Swimmers:\")\n",
    "    print(f\"  Best Strategy: {best_strategy} ({swimmer_data.iloc[0]['Total_Time']:.2f}s)\")\n",
    "    print(f\"  Worst Strategy: {worst_strategy} ({swimmer_data.iloc[-1]['Total_Time']:.2f}s)\")\n",
    "    print(f\"  Potential Improvement: {time_diff:.2f} seconds\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3.4 Creating Custom Training Sets Based on Data\n",
    "\n",
    "Let's use our data analysis to create customized training sets for different swimmer types and goals."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_training_set(swimmer_type, focus_area, base_time_100m, total_distance=2000):\n",
    "    \"\"\"Generate a custom training set based on swimmer characteristics and focus area\n",
    "    \n",
    "    Parameters:\n",
    "    swimmer_type (str): 'Sprinter', 'Distance', or 'Balanced'\n",
    "    focus_area (str): 'Endurance', 'Speed', 'Race_Pace', or 'Technique'\n",
    "    base_time_100m (float): Swimmer's current 100m time in seconds\n",
    "    total_distance (int): Approximate total distance for the set\n",
    "    \n",
    "    Returns:\n",
    "    DataFrame: Custom training set\n",
    "    \"\"\"\n",
    "    \n",
    "    # Define training set parameters based on swimmer type and focus area\n",
    "    if focus_area == 'Endurance':\n",
    "        if swimmer_type == 'Sprinter':\n",
    "            # Sprinters need more rest in endurance sets\n",
    "            distances = [100, 200, 300, 200, 100, 200, 300, 200, 100]\n",
    "            intensity = 0.75  # Percentage of max effort\n",
    "            rest_factor = 0.5  # Rest as a proportion of swim time\n",
    "        elif swimmer_type == 'Distance':\n",
    "            # Distance swimmers can handle longer reps with less rest\n",
    "            distances = [200, 300, 400, 400, 300, 200]\n",
    "            intensity = 0.80\n",
    "            rest_factor = 0.2\n",
    "        else:  # Balanced\n",
    "            distances = [100, 200, 300, 300, 200, 100]\n",
    "            intensity = 0.78\n",
    "            rest_factor = 0.3\n",
    "    \n",
    "    elif focus_area == 'Speed':\n",
    "        if swimmer_type == 'Sprinter':\n",
    "            # Sprinters excel with short, fast efforts\n",
    "            distances = [25, 25, 25, 25, 50, 50, 50, 50, 25, 25, 25, 25, 50, 50, 50, 50]\n",
    "            intensity = 0.95\n",
    "            rest_factor = 2.0\n",
    "        elif swimmer_type == 'Distance':\n",
    "            # Distance swimmers need more speed work\n",
    "            distances = [50, 50, 50, 100, 100, 50, 50, 50, 100, 100]\n",
    "            intensity = 0.90\n",
    "            rest_factor = 1.5\n",
    "        else:  # Balanced\n",
    "            distances = [25, 50, 75, 75, 50, 25, 25, 50, 75, 75, 50, 25]\n",
    "            intensity = 0.92\n",
    "            rest_factor = 1.8\n",
    "    \n",
    "    elif focus_area == 'Race_Pace':\n",
    "        if swimmer_type == 'Sprinter':\n",
    "            # Race pace work for sprinters\n",
    "            distances = [50, 50, 50, 100, 100, 50, 50, 50, 100, 100]\n",
    "            intensity = 0.90\n",
    "            rest_factor = 1.5\n",
    "        elif swimmer_type == 'Distance':\n",
    "            # Race pace work for distance swimmers\n",
    "            distances = [100, 200, 200, 100, 100, 200, 200, 100]\n",
    "            intensity = 0.88\n",
    "            rest_factor = 0.8\n",
    "        else:  # Balanced\n",
    "            distances = [100, 100, 200, 100, 100, 200, 100, 100]\n",
    "            intensity = 0.89\n",
    "            rest_factor = 1.0\n",
    "    \n",
    "    elif focus_area == 'Technique':\n",
    "        if swimmer_type == 'Sprinter':\n",
    "            # Technique work for sprinters\n",
    "            distances = [25, 50, 75, 100, 100, 75, 50, 25, 25, 50, 75, 100, 100, 75, 50, 25]\n",
    "            intensity = 0.70\n",
    "            rest_factor = 0.5\n",
    "        elif swimmer_type == 'Distance':\n",
    "            # Technique work for distance swimmers\n",
    "            distances = [50, 100, 150, 200, 200, 150, 100, 50]\n",
    "            intensity = 0.70\n",
    "            rest_factor = 0.3\n",
    "        else:  # Balanced\n",
    "            distances = [50, 50, 100, 100, 150, 150, 100, 100, 50, 50]\n",
    "            intensity = 0.70\n",
    "            rest_factor = 0.4\n",
    "    \n",
    "    # Adjust the set to match the target total distance\n",
    "    current_distance = sum(distances)\n",
    "    scale_factor = total_distance / current_distance\n",
    "    \n",
    "    # Round to nearest 25m\n",
    "    adjusted_distances = [round(d * scale_factor / 25) * 25 for d in distances]\n",
    "    \n",
    "    # Create the training set\n",
    "    training_set = []\n",
    "    \n",
    "    for distance in adjusted_distances:\n",
    "        # Calculate target time based on intensity and base time\n",
    "        target_100m = base_time_100m / intensity\n",
    "        target_time = target_100m * distance / 100\n",
    "        \n",
    "        # Calculate rest interval\n",
    "        rest_time = target_time * rest_factor\n",
    "        \n",
    "        # Format times as MM:SS\n",
    "        target_time_formatted = f\"{int(target_time // 60):01d}:{target_time % 60:04.1f}\"\n",
    "        rest_time_formatted = f\"{int(rest_time // 60):01d}:{rest_time % 60:04.1f}\"\n",
    "        \n",
    "        # Add to training set\n",
    "        training_set.append({\n",
    "            'Distance': distance,\n",
    "            'Target_Time': target_time_formatted,\n",
    "            'Rest': rest_time_formatted,\n",
    "            'Pace_100m': f\"{target_100m:.1f}\"\n",
    "        })\n",
    "    \n",
    "    # Create a dataframe\n",
    "    training_df = pd.DataFrame(training_set)\n",
    "    \n",
    "    # Add a summary\n",
    "    total_adjusted_distance = sum(adjusted_distances)\n",
    "    total_set_time = sum([distance / 100 * (base_time_100m / intensity) for distance in adjusted_distances])\n",
    "    total_rest_time = sum([distance / 100 * (base_time_100m / intensity) * rest_factor for distance in adjusted_distances])\n",
    "    \n",
    "    print(f\"Training Set for {swimmer_type} Swimmer - {focus_area} Focus\")\n",
    "    print(f\"Total Distance: {total_adjusted_distance}m\")\n",
    "    print(f\"Intensity: {intensity*100:.0f}% of max effort\")\n",
    "    print(f\"Estimated Total Time: {(total_set_time + total_rest_time) / 60:.1f} minutes\")\n",
    "    print(f\"Base 100m Time: {base_time_100m:.1f} seconds\")\n",
    "    print()\n",
    "    \n",
    "    return training_df\n",
    "\n",
    "# Example: Generate a training set for a sprinter focusing on endurance\n",
    "training_set = generate_training_set(\n",
    "    swimmer_type='Sprinter',\n",
    "    focus_area='Endurance',\n",
    "    base_time_100m=60.0,  # 1:00.0 for 100m\n",
    "    total_distance=2000\n",
    ")\n",
    "\n",
    "training_set"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Generate different types of training sets for comparison\n",
    "print(\"Comparing Training Sets for Different Focus Areas:\")\n",
    "print(\"-\" * 50)\n",
    "\n",
    "# Distance swimmer focusing on speed\n",
    "training_set1 = generate_training_set(\n",
    "    swimmer_type='Distance',\n",
    "    focus_area='Speed',\n",
    "    base_time_100m=62.0,  # 1:02.0 for 100m\n",
    "    total_distance=1500\n",
    ")\n",
    "display(training_set1)\n",
    "print(\"-\" * 50)\n",
    "\n",
    "# Balanced swimmer focusing on race pace\n",
    "training_set2 = generate_training_set(\n",
    "    swimmer_type='Balanced',\n",
    "    focus_area='Race_Pace',\n",
    "    base_time_100m=58.0,  # 0:58.0 for 100m\n",
    "    total_distance=1800\n",
    ")\n",
    "display(training_set2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3.5 Putting It All Together: Comprehensive Swimmer Analysis\n",
    "\n",
    "Let's create a comprehensive analysis function that combines all the techniques we've learned."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def comprehensive_swimmer_analysis(swimmer_id, swimmer_db, performance_db, race_split_data=None):\n",
    "    \"\"\"Provide a comprehensive analysis of a swimmer's performance and potential\"\"\"\n",
    "    \n",
    "    # Get swimmer information\n",
    "    swimmer = swimmer_db[swimmer_db['SwimmerID'] == swimmer_id].iloc[0]\n",
    "    \n",
    "    # Get performance data\n",
    "    performances = performance_db[performance_db['SwimmerID'] == swimmer_id].sort_values('AssessmentID')\n",
    "    \n",
    "    # Display swimmer information\n",
    "    print(f\"Comprehensive Analysis for {swimmer['Name']}\")\n",
    "    print(f\"Age: {swimmer['Age']} | Gender: {'Male' if swimmer['Gender'] == 'M' else 'Female'} | Experience: {swimmer['Years_Experience']} years\")\n",
    "    print(\"-\" * 80)\n",
    "    \n",
    "    # 1. Performance Trend Analysis\n",
    "    print(\"1. Performance Trend Analysis\")\n",
    "    \n",
    "    # Calculate improvement\n",
    "    if len(performances) >= 2:\n",
    "        initial_time = performances.iloc[0]['Time']\n",
    "        final_time = performances.iloc[-1]['Time']\n",
    "        improvement = initial_time - final_time\n",
    "        improvement_percent = (improvement / initial_time) * 100\n",
    "        \n",
    "        print(f\"   Initial Time: {initial_time:.2f}s → Final Time: {final_time:.2f}s\")\n",
    "        print(f\"   Improvement: {improvement:.2f}s ({improvement_percent:.1f}%)\")\n",
    "        \n",
    "        # Calculate rate of improvement\n",
    "        if len(performances) > 2:\n",
    "            # Linear regression to get trend\n",
    "            x = performances['AssessmentID'].values.reshape(-1, 1)\n",
    "            y = performances['Time'].values\n",
    "            model = LinearRegression().fit(x, y)\n",
    "            slope = model.coef_[0]\n",
    "            \n",
    "            print(f\"   Rate of Improvement: {-slope:.2f}s per assessment period\")\n",
    "            \n",
    "            # Predict future performance\n",
    "            next_assessment = performances['AssessmentID'].max() + 1\n",
    "            predicted_time = model.predict([[next_assessment]])[0]\n",
    "            \n",
    "            print(f\"   Predicted Time (Next Assessment): {predicted_time:.2f}s\")\n",
    "    else:\n",
    "        print(\"   Insufficient data for trend analysis\")\n",
    "    \n",
    "    print()\n",
    "    \n",
    "    # 2. Stroke Efficiency Analysis\n",
    "    print(\"2. Stroke Efficiency Analysis\")\n",
    "    \n",
    "    if not performances.empty:\n",
    "        latest = performances.iloc[-1]\n",
    "        \n",
    "        print(f\"   Current Velocity: {latest['Velocity']:.2f} m/s\")\n",
    "        print(f\"   Current Stroke Rate: {latest['Stroke_Rate']:.1f} strokes/min\")\n",
    "        print(f\"   Current Stroke Length: {latest['Stroke_Length']:.2f} m\")\n",
    "        print(f\"   Current Efficiency (SI): {latest['Stroke_Index']:.2f}\")\n",
    "        \n",
    "        # Compare to previous assessment if available\n",
    "        if len(performances) >= 2:\n",
    "            previous = performances.iloc[-2]\n",
    "            \n",
    "            sl_change = latest['Stroke_Length'] - previous['Stroke_Length']\n",
    "            sr_change = latest['Stroke_Rate'] - previous['Stroke_Rate']\n",
    "            si_change = latest['Stroke_Index'] - previous['Stroke_Index']\n",
    "            \n",
    "            sl_change_pct = (sl_change / previous['Stroke_Length']) * 100\n",
    "            sr_change_pct = (sr_change / previous['Stroke_Rate']) * 100\n",
    "            si_change_pct = (si_change / previous['Stroke_Index']) * 100\n",
    "            \n",
    "            print(\"\\n   Changes from Previous Assessment:\")\n",
    "            print(f\"     Stroke Length: {sl_change:+.2f}m ({sl_change_pct:+.1f}%)\")\n",
    "            print(f\"     Stroke Rate: {sr_change:+.1f} spm ({sr_change_pct:+.1f}%)\")\n",
    "            print(f\"     Efficiency: {si_change:+.2f} ({si_change_pct:+.1f}%)\")\n",
    "            \n",
    "            # Technique development insights\n",
    "            print(\"\\n   Technique Development Insights:\")\n",
    "            if sl_change > 0 and sr_change < 0:\n",
    "                print(\"     → Developing a longer, more efficient stroke but sacrificing turnover\")\n",
    "            elif sl_change < 0 and sr_change > 0:\n",
    "                print(\"     → Developing a faster turnover but sacrificing stroke length\")\n",
    "            elif sl_change > 0 and sr_change > 0:\n",
    "                print(\"     → Excellent development: improving both stroke length and rate\")\n",
    "            elif sl_change < 0 and sr_change < 0:\n",
    "                print(\"     → Concerning trend: decreasing both stroke length and rate\")\n",
    "            \n",
    "            if si_change > 0:\n",
    "                print(\"     → Overall efficiency is improving\")\n",
    "            else:\n",
    "                print(\"     → Overall efficiency is declining\")\n",
    "    else:\n",
    "        print(\"   No performance data available\")\n",
    "    \n",
    "    print()\n",
    "        # Elite swimmer 1: Very consistent timing
        [0.0, 1.2, 2.4, 3.6, 4.8, 6.0, 7.2, 8.4, 9.6, 10.8],
        # Elite swimmer 2: Slight variation but consistent
        [0.0, 1.3, 2.5, 3.8, 5.0, 6.3, 7.5, 8.8, 10.0, 11.3],
        # Age group swimmer 1: Less consistent
        [0.0, 1.4, 2.7, 4.2, 5.5, 7.1, 8.4, 10.0, 11.5, 13.2],
        # Age group swimmer 2: Very inconsistent
        [0.0, 1.5, 3.2, 4.7, 6.5, 8.0, 10.0, 11.8, 14.0, 16.0]
    ]\n",
    "})\n",
    "\n",
    "# Function to analyze stroke timing\n",
    "def analyze_stroke_timing(events):\n",
    "    # Calculate stroke durations\n",
    "    durations = [events[i+1] - events[i] for i in range(len(events)-1)]\n",
    "    \n",
    "    # Calculate statistics\n",
    "    avg_duration = np.mean(durations)\n",
    "    std_duration = np.std(durations)\n",
    "    cv = (std_duration / avg_duration) * 100  # Coefficient of variation as percentage\n",
    "    \n",
    "    # Stroke rate in strokes per minute\n",
    "    stroke_rate = 60 / avg_duration\n",
    "    \n",
    "    return {\n",
    "        'durations': durations,\n",
    "        'avg_duration': avg_duration,\n",
    "        'std_duration': std_duration,\n",
    "        'cv': cv,\n",
    "        'stroke_rate': stroke_rate\n",
    "    }\n",
    "\n",
    "# Analyze all swimmers\n",
    "timing_results = []\n",
    "for i, row in swimmer_data.iterrows():\n",
    "    analysis = analyze_stroke_timing(row['Events'])\n",
    "    timing_results.append({\n",
    "        'Swimmer': row['Swimmer'],\n",
    "        'Stroke': row['Stroke'],\n",
    "        'Avg Duration (s)': analysis['avg_duration'],\n",
    "        'Consistency (CV%)': analysis['cv'],\n",
    "        'Stroke Rate (spm)': analysis['stroke_rate']\n",
    "    })\n",
    "\n",
    "timing_df = pd.DataFrame(timing_results)\n",
    "timing_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize the stroke timing\n",
    "plt.figure(figsize=(14, 8))\n",
    "\n",
    "for i, row in swimmer_data.iterrows():\n",
    "    # Plot the stroke events as vertical lines\n",
    "    for event in row['Events']:\n",
    "        plt.axvline(x=event, color=f'C{i}', linestyle='--', alpha=0.3)\n",
    "    \n",
    "    # Plot points at each event\n",
    "    plt.plot(row['Events'], [i] * len(row['Events']), 'o-', label=row['Swimmer'], markersize=8)\n",
    "\n",
    "plt.yticks(range(len(swimmer_data)), swimmer_data['Swimmer'])\n",
    "plt.title('Stroke Timing Comparison')\n",
    "plt.xlabel('Time (seconds)')\n",
    "plt.grid(True, axis='x')\n",
    "plt.legend(loc='upper right')\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Visualize the consistency of stroke durations\n",
    "plt.figure(figsize=(14, 8))\n",
    "\n",
    "for i, row in swimmer_data.iterrows():\n",
    "    analysis = analyze_stroke_timing(row['Events'])\n",
    "    durations = analysis['durations']\n",
    "    \n",
    "    # Plot the stroke durations\n",
    "    plt.plot(range(1, len(durations)+1), durations, 'o-', label=row['Swimmer'], markersize=8)\n",
    "\n",
    "plt.title('Stroke Duration Consistency')\n",
    "plt.xlabel('Stroke Number')\n",
    "plt.ylabel('Duration (seconds)')\n",
    "plt.grid(True)\n",
    "plt.legend(loc='upper right')\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Coaching Insights from Rhythm Analysis\n",
    "\n",
    "Analyzing stroke rhythm can provide valuable insights for coaching:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Generate coaching recommendations based on rhythm analysis\n",
    "def rhythm_coaching_insights(timing_df):\n",
    "    for _, row in timing_df.iterrows():\n",
    "        print(f\"Coaching Insights for {row['Swimmer']} ({row['Stroke']}):\")\n",
    "        print(f\"  Average Stroke Duration: {row['Avg Duration (s)']:.2f} seconds\")\n",
    "        print(f\"  Stroke Rate: {row['Stroke Rate (spm)']:.1f} strokes per minute\")\n",
    "        print(f\"  Consistency (CV%): {row['Consistency (CV%)']:.1f}%\")\n",
    "        \n",
    "        # General insights based on consistency\n",
    "        if row['Consistency (CV%)'] < 3:\n",
    "            print(\"  ✓ Excellent rhythm consistency - typical of elite swimmers\")\n",
    "        elif row['Consistency (CV%)'] < 8:\n",
    "            print(\"  ✓ Good rhythm consistency - room for small improvements\")\n",
    "        elif row['Consistency (CV%)'] < 15:\n",
    "            print(\"  ⚠ Moderate rhythm inconsistency - focus on developing a more consistent stroke\")\n",
    "        else:\n",
    "            print(\"  ⚠ Significant rhythm inconsistency - prioritize drills to develop stroke timing\")\n",
    "        \n",
    "        # Specific recommendations based on stroke rate\n",
    "        if row['Stroke'] == 'Freestyle':\n",
    "            if row['Stroke Rate (spm)'] < 40:\n",
    "                print(\"  → Consider increasing stroke rate while maintaining stroke length\")\n",
    "            elif row['Stroke Rate (spm)'] > 70:\n",
    "                print(\"  → Consider whether stroke length is being sacrificed for high turnover\")\n",
    "        print()\n",
    "\n",
    "# Generate coaching insights\n",
    "rhythm_coaching_insights(timing_df)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.4 Exercise: Analyze Your Own Swimmer's Technique\n",
    "\n",
    "Now it's your turn to analyze swimming technique. If you have video footage of one of your swimmers, you can use the tools we've developed to analyze their stroke."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise template\n",
    "\n",
    "# Step 1: Analyze video if available\n",
    "# analyze_swimming_video('path/to/your/swimming_video.mp4')\n",
    "\n",
    "# Step 2: Calculate stroke parameters\n",
    "# calculate_stroke_parameters_from_video('path/to/your/swimming_video.mp4', pool_length=25)\n",
    "\n",
    "# Step 3: If you have stroke timing data, analyze it\n",
    "# custom_events = [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5]\n",
    "# custom_analysis = analyze_stroke_timing(custom_events)\n",
    "# print(f\"Average Stroke Duration: {custom_analysis['avg_duration']:.2f} seconds\")\n",
    "# print(f\"Stroke Rate: {custom_analysis['stroke_rate']:.1f} strokes per minute\")\n",
    "# print(f\"Consistency (CV%): {custom_analysis['cv']:.1f}%\")\n",
    "\n",
    "# Step 4: Formulate coaching recommendations based on your analysis\n",
    "# print(\"\\nCoaching Recommendations:\")\n",
    "# print(\"1. [Your first recommendation]\")\n",
    "# print(\"2. [Your second recommendation]\")\n",
    "# print(\"3. [Your third recommendation]\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Day 2 Summary and Key Takeaways\n",
    "\n",
    "Today we've explored video analysis techniques to quantify and improve swimming technique:\n",
    "\n",
    "1. **Basic Video Analysis**:\n",
    "   - Extracting key metrics from video footage\n",
    "   - Calculating stroke parameters without specialized equipment\n",
    "\n",
    "2. **Advanced Stroke Analysis**:\n",
    "   - Hand path tracking and analysis\n",
    "   - Comparing technique between swimmers\n",
    "   - Identifying technical inefficiencies\n",
    "\n",
    "3. **Rhythm and Timing Analysis**:\n",
    "   - Quantifying stroke consistency\n",
    "   - Analyzing stroke timing patterns\n",
    "   - Developing timing-specific recommendations\n",
    "\n",
    "### Homework Assignment\n",
    "\n",
    "Before Day 3, please:\n",
    "1. Record a short video (15-30 seconds) of one of your swimmers\n",
    "2. Identify 2-3 key technical aspects to analyze\n",
    "3. Plan a drill progression to address any technique issues\n",
    "4. Be prepared to discuss your analysis and recommendations"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Day 3: Advanced Analytics and Interactive Dashboards\n",
    "\n",
    "On our final day, we'll build advanced analytics tools and interactive dashboards to track swimmer progress."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3.1 Creating Interactive Dashboards for Swimmers\n",
    "\n",
    "Interactive dashboards allow coaches and swimmers to visualize performance data in an intuitive way. We'll use Dash and Plotly to create a simple dashboard."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries\n",
    "import plotly.express as px\n",
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "\n",
    "# Let's use our swimmer database from Day 1\n",
    "swimmers_db, performances_db = create_swimmer_database()\n",
    "\n",
    "# Merge the data for easier access\n",
    "merged_data = pd.merge(performances_db, swimmers_db[['SwimmerID', 'Name', 'Age', 'Gender']], on='SwimmerID')\n",
    "\n",
    "# Create interactive visualizations\n",
    "# First, let's create a scatter plot of stroke length vs velocity\n",
    "fig = px.scatter(merged_data, x=\"Stroke_Length\", y=\"Velocity\", \n",
    "                 color=\"Name\", size=\"Stroke_Index\", hover_name=\"Name\",\n",
    "                 hover_data=[\"Time\", \"Stroke_Rate\"],\n",
    "                 labels={\"Stroke_Length\": \"Stroke Length (m)\", \n",
    "                         \"Velocity\": \"Velocity (m/s)\",\n",
    "                         \"Stroke_Index\": \"Efficiency\"},\n",
    "                 title=\"Stroke Length vs. Velocity\")\n",
    "\n",
    "fig.update_layout(height=600, width=800)\n",
    "fig.show()\n",
    "\n",
    "# Now, let's create a dashboard-style visualization with multiple charts\n",
    "# Create subplots with 2 rows and 2 columns\n",
    "fig = make_subplots(\n",
    "    rows=2, cols=2,\n",
    "    subplot_titles=(\n",
    "        \"Time Progression\", \n",
    "        \"Stroke Length vs. Stroke Rate\", \n",
    "        \"Efficiency by Assessment\", \n",
    "        \"Time Distribution by Gender\"\n",
    "    )\n",
    ")\n",
    "\n",
    "# Add time progression lines for each swimmer\n",
    "for swimmer_id in swimmers_db['SwimmerID'].unique():\n",
    "    swimmer_data = merged_data[merged_data['SwimmerID'] == swimmer_id]\n",
    "    name = swimmer_data['Name'].iloc[0]\n",
    "    \n",
    "    fig.add_trace(\n",
    "        go.Scatter(\n",
    "            x=swimmer_data['AssessmentID'],\n",
    "            y=swimmer_data['Time'],\n",
    "            mode='lines+markers',\n",
    "            name=name\n",
    "        ),\n",
    "        row=1, col=1\n",
    "    )\n",
    "    \n",
    "# Add stroke length vs. stroke rate scatter plot\n",
    "fig.add_trace(\n",
    "    go.Scatter(\n",
    "        x=merged_data['Stroke_Rate'],\n",
    "        y=merged_data['Stroke_Length'],\n",
    "        mode='markers',\n",
    "        marker=dict(\n",
    "            size=merged_data['Stroke_Index'] * 5,\n",
    "            color=merged_data['Velocity'],\n",
    "            colorscale='Viridis',\n",
    "            showscale=True,\n",
    "            colorbar=dict(title=\"Velocity (m/s)\")\n",
    "        ),\n",
    "        text=merged_data['Name'],\n",
    "        hovertemplate='Name: %{text}<br>Stroke Rate: %{x:.1f}<br>Stroke Length: %{y:.2f}<extra></extra>'\n",
    "    ),\n",
    "    row=1, col=2\n",
    ")\n",
    "\n",
    "# Add efficiency by assessment boxplot\n",
    "for assessment_id in sorted(merged_data['AssessmentID'].unique()):\n",
    "    assessment_data = merged_data[merged_data['AssessmentID'] == assessment_id]\n",
    "    \n",
    "    fig.add_trace(\n",
    "        go.Box(\n",
    "            y=assessment_data['Stroke_Index'],\n",
    "            name=f\"Assessment {assessment_id}\",\n",
    "            boxpoints='all',\n",
    "            jitter=0.3,\n",
    "            pointpos=-1.8,\n",
    "            text=assessment_data['Name'],\n",
    "            hovertemplate='Name: %{text}<br>Efficiency: %{y:.2f}<extra></extra>'\n",
    "        ),\n",
    "        row=2, col=1\n",
    "    )\n",
    "\n",
    "# Add time distribution by gender violin plot\n",
    "fig.add_trace(\n",
    "    go.Violin(\n",
    "        x=merged_data['Gender'],\n",
    "        y=merged_data['Time'],\n",
    "        box_visible=True,\n",
    "        meanline_visible=True,\n",
    "        points=\"all\",\n",
    "        text=merged_data['Name'],\n",
    "        hovertemplate='Name: %{text}<br>Time: %{y:.2f}<extra></extra>'\n",
    "    ),\n",
    "    row=2, col=2\n",
    ")\n",
    "\n",
    "# Update layout\n",
    "fig.update_layout(\n",
    "    height=800,\n",
    "    width=1000,\n",
    "    title_text=\"Swimmer Performance Dashboard\",\n",
    "    showlegend=False\n",
    ")\n",
    "\n",
    "# Update axes labels\n",
    "fig.update_xaxes(title_text=\"Assessment\", row=1, col=1)\n",
    "fig.update_yaxes(title_text=\"Time (seconds)\", row=1, col=1)\n",
    "\n",
    "fig.update_xaxes(title_text=\"Stroke Rate (spm)\", row=1, col=2)\n",
    "fig.update_yaxes(title_text=\"Stroke Length (m)\", row=1, col=2)\n",
    "\n",
    "fig.update_xaxes(title_text=\"Assessment\", row=2, col=1)\n",
    "fig.update_yaxes(title_text=\"Efficiency (SI)\", row=2, col=1)\n",
    "\n",
    "fig.update_xaxes(title_text=\"Gender\", row=2, col=2)\n",
    "fig.update_yaxes(title_text=\"Time (seconds)\", row=2, col=2)\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3.2 Predictive Models for Swimming Performance\n",
    "\n",
    "Let's explore how machine learning can help predict swimming performance and identify key factors affecting improvement."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import the necessary libraries\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.linear_model import LinearRegression\n",
    "from sklearn.ensemble import RandomForestRegressor\n",
    "from sklearn.metrics import mean_squared_error, r2_score\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "# Create a larger dataset for modeling\n",
    "# This is a simple synthetic dataset for demonstration purposes\n",
    "np.random.seed(42)\n",
    "\n",
    "# Create features for swimmers\n",
    "n_swimmers = 100\n",
    "swimmer_features = pd.DataFrame({\n",
    "    'SwimmerID': range(1, n_swimmers + 1),\n",
    "    'Age': np.random.randint(12, 19, n_swimmers),\n",
    "    'Height_cm': np.random.normal(170, 10, n_swimmers),\n",
    "    'Years_Experience': np.random.randint(1, 10, n_swimmers),\n",
    "    'Weekly_Hours': np.random.uniform(4, 20, n_swimmers),\n",
    "    'Strength_Training': np.random.choice([0, 1], n_swimmers, p=[0.7, 0.3]),\n",
    "    'Nutrition_Score': np.random.randint(1, 11, n_swimmers),\n",
    "    'Flexibility_Score': np.random.randint(1, 11, n_swimmers),\n",
    "    'Gender': np.random.choice(['M', 'F'], n_swimmers, p=[0.5, 0.5])\n",
    "})\n",
    "\n",
    "# Add initial 100m freestyle time\n",
    "# Base time around 65 seconds with adjustments based on features\n",
    "swimmer_features['Initial_Time'] = 65 \\\n",
    "    - (swimmer_features['Height_cm'] - 170) * 0.1 \\\n",
    "    - swimmer_features['Years_Experience'] * 0.5 \\\n",
    "    - swimmer_features['Weekly_Hours'] * 0.3 \\\n",
    "    - swimmer_features['Strength_Training'] * 2 \\\n",
    "    - swimmer_features['Nutrition_Score'] * 0.2 \\\n",
    "    - swimmer_features['Flexibility_Score'] * 0.1 \\\n",
    "    + (np.random.normal(0, 2, n_swimmers))  # Add some random variation\n",
    "\n",
    "# Add gender effect (for simplicity, making males slightly faster on average)\n",
    "gender_adj = np.where(swimmer_features['Gender'] == 'M', -1.5, 1.5)\n",
    "swimmer_features['Initial_Time'] += gender_adj\n",
    "\n",
    "# Create 1-year improvement based on training factors\n",
    "swimmer_features['Improvement'] = 2 \\\n",
    "    + swimmer_features['Weekly_Hours'] * 0.2 \\\n",
    "    + swimmer_features['Strength_Training'] * 1 \\\n",
    "    + swimmer_features['Nutrition_Score'] * 0.15 \\\n",
    "    + swimmer_features['Flexibility_Score'] * 0.1 \\\n",
    "    - swimmer_features['Years_Experience'] * 0.1  # Diminishing returns with experience\n",
    "\n",
    "# Add age effect (teenagers improve faster)\n",
    "age_adj = -0.1 * (swimmer_features['Age'] - 15)**2 + 0.5  # Quadratic effect peaking at age 15\n",
    "swimmer_features['Improvement'] += age_adj\n",
    "\n",
    "# Add some random variation\n",
    "swimmer_features['Improvement'] += np.random.normal(0, 0.5, n_swimmers)\n",
    "\n",
    "# Ensure improvement is positive\n",
    "swimmer_features['Improvement'] = np.maximum(0.1, swimmer_features['Improvement'])\n",
    "\n",
    "# Calculate the final time\n",
    "swimmer_features['Final_Time'] = swimmer_features['Initial_Time'] - swimmer_features['Improvement']\n",
    "\n",
    "# Display the head of the dataset\n",
    "swimmer_features.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Build a predictive model for improvement\n",
    "\n",
    "# Convert categorical variables to numeric\n",
    "# (Scikit-learn requires numeric input)\n",
    "features = swimmer_features.copy()\n",
    "features['Gender'] = features['Gender'].map({'M': 0, 'F': 1})\n",
    "\n",
    "# Select features and target\n",
    "X = features[['Age', 'Height_cm', 'Years_Experience', 'Weekly_Hours', \n",
    "              'Strength_Training', 'Nutrition_Score', 'Flexibility_Score', 'Gender']]\n",
    "y = features['Improvement']\n",
    "\n",
    "# Split the data\n",
    "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n",
    "\n",
    "# Standardize the features\n",
    "scaler = StandardScaler()\n",
    "X_train_scaled = scaler.fit_transform(X_train)\n",
    "X_test_scaled = scaler.transform(X_test)\n",
    "\n",
    "# Train a linear regression model\n",
    "lr_model = LinearRegression()\n",
    "lr_model.fit(X_train_scaled, y_train)\n",
    "\n",
    "# Train a random forest model\n",
    "rf_model = RandomForestRegressor(n_estimators=100, random_state=42)\n",
    "rf_model.fit(X_train, y_train)  # Random forests don't require scaling\n",
    "\n",
    "# Make predictions\n",
    "lr_pred = lr_model.predict(X_test_scaled)\n",
    "rf_pred = rf_model.predict(X_test)\n",
    "\n",
    "# Evaluate the models\n",
    "print(\"Linear Regression Model:\")\n",
    "print(f\"  RMSE: {np.sqrt(mean_squared_error(y_test, lr_pred)):.3f}\")\n",
    "print(f\"  R²: {r2_score(y_test, lr_pred):.3f}\")\n",
    "print(\"\\nRandom Forest Model:\")\n",
    "print(f\"  RMSE: {np.sqrt(mean_squared_error(y_test, rf_pred)):.3f}\")\n",
    "print(f\"  R²: {r2_score(y_test, rf_pred):.3f}\")\n",
    "\n",
    "# Analyze feature importance\n",
    "feature_importance_df = pd.DataFrame({\n",
    "    'Feature': X.columns,\n",
    "    'Linear_Regression_Coefficient': lr_model.coef_,\n",
    "    'Random_Forest_Importance': rf_model.feature_importances_\n",
    "})\n",
    "\n",
    "# Normalize linear regression coefficients for comparison\n",
    "feature_importance_df['Linear_Regression_Coefficient'] = abs(feature_importance_df['Linear_Regression_Coefficient'])\n",
    "feature_importance_df['Linear_Regression_Coefficient'] /= feature_importance_df['Linear_Regression_Coefficient'].sum()\n",
    "\n",
    "# Sort by random forest importance\n",
    "feature_importance_df = feature_importance_df.sort_values('Random_Forest_Importance', ascending=False)\n",
    "\n",
    "feature_importance_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize feature importance\n",
    "plt.figure(figsize=(12, 6))\n",
    "\n",
    "plt.subplot(1, 2, 1)\n",
    "plt.bar(feature_importance_df['Feature'], feature_importance_df['Linear_Regression_Coefficient'])\n",
    "plt.title('Linear Regression Coefficients')\n",
    "plt.xticks(rotation=45, ha='right')\n",
    "plt.ylim(0, max(feature_importance_df['Linear_Regression_Coefficient']) * 1.1)\n",
    "\n",
    "plt.subplot(1, 2, 2)\n",
    "plt.bar(feature_importance_df['Feature'], feature_importance_df['Random_Forest_Importance'])\n",
    "plt.title('Random Forest Feature Importance')\n",
    "plt.xticks(rotation=45, ha='right')\n",
    "plt.ylim(0, max(feature_importance_df['Random_Forest_Importance']) * 1.1)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Make predictions for new swimmers\n",
    "def predict_improvement(age, height, experience, weekly_hours, strength_training, nutrition, flexibility, gender):\n",
    "    # Create a dataframe with the swimmer's features\n",
    "    new_swimmer = pd.DataFrame({\n",
    "        'Age': [age],\n",
    "        'Height_cm': [height],\n",
    "        'Years_Experience': [experience],\n",
    "        'Weekly_Hours': [weekly_hours],\n",
    "        'Strength_Training': [strength_training],\n",
    "        'Nutrition_Score': [nutrition],\n",
    "        'Flexibility_Score': [flexibility],\n",
    "        'Gender': [1 if gender == 'F' else 0]\n",
    "    })\n",
    "    \n",
    "    # Scale the features\n",
    "    new_swimmer_scaled = scaler.transform(new_swimmer)\n",
    "    \n",
    "    # Make predictions\n",
    "    lr_improvement = lr_model.predict(new_swimmer_scaled)[0]\n",
    "    rf_improvement = rf_model.predict(new_swimmer)[0]\n",
    "    \n",
    "    # Average the predictions\n",
    "    avg_improvement = (lr_improvement + rf_improvement) / 2\n",
    "    \n",
    "    print(f\"Predicted Improvement (Linear Regression): {lr_improvement:.2f} seconds\")\n",
    "    print(f\"Predicted Improvement (Random Forest): {rf_improvement:.2f} seconds\")\n   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise: Create Your Own Pacing Strategy Analysis\n",
    "\n",
    "Now it's your turn to analyze real or hypothetical race data. Create a pacing strategy for a 200m race based on different swimming event types (e.g., freestyle, butterfly, individual medley) and swimmer types (e.g., sprinter, distance swimmer). What would be the ideal pacing strategy for each?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise template\n",
    "\n",
    "# Create a custom race strategy for different event types\n",
    "custom_race_data = pd.DataFrame({\n",
    "    'Swimmer': ['Sprinter', 'Distance', 'Balanced', 'Your Strategy'],\n",
    "    'Event': ['200 Free', '200 Free', '200 Free', '200 Free'],\n",
    "    'Split_50m': [24.5, 26.0, 25.5, 0.0],  # First 50m split in seconds\n",
    "    'Split_100m': [26.5, 26.2, 26.0, 0.0],  # Second 50m split\n",
    "    'Split_150m': [27.5, 26.0, 26.2, 0.0],  # Third 50m split\n",
    "    'Split_200m': [28.5, 25.8, 26.3, 0.0],  # Fourth 50m split\n",
    "})\n",
    "\n",
    "# Fill in your own strategy in the last row\n",
    "# custom_race_data.loc[3, 'Split_50m'] = your_value_here\n",
    "# custom_race_data.loc[3, 'Split_100m'] = your_value_here\n",
    "# custom_race_data.loc[3, 'Split_150m'] = your_value_here\n",
    "# custom_race_data.loc[3, 'Split_200m'] = your_value_here\n",
    "\n",
    "# Calculate cumulative times\n",
    "custom_race_data['Time_50m'] = custom_race_data['Split_50m']\n",
    "custom_race_data['Time_100m'] = custom_race_data['Split_50m'] + custom_race_data['Split_100m']\n",
    "custom_race_data['Time_150m'] = custom_race_data['Split_50m'] + custom_race_data['Split_100m'] + custom_race_data['Split_150m']\n",
    "custom_race_data['Time_200m'] = custom_race_data['Split_50m'] + custom_race_data['Split_100m'] + custom_race_data['Split_150m'] + custom_race_data['Split_200m']\n",
    "\n",
    "# Calculate pacing (normalized to first 50m)\n",
    "custom_race_data['Pace_50m'] = 1.0  # First 50 is the reference\n",
    "custom_race_data['Pace_100m'] = custom_race_data['Split_100m'] / custom_race_data['Split_50m']\n",
    "custom_race_data['Pace_150m'] = custom_race_data['Split_150m'] / custom_race_data['Split_50m']\n",
    "custom_race_data['Pace_200m'] = custom_race_data['Split_200m'] / custom_race_data['Split_50m']\n",
    "\n",
    "# Visualize your custom race strategies (only showing strategies with complete data)\n",
    "valid_data = custom_race_data[custom_race_data['Split_50m'] > 0]\n",
    "\n",
    "# Plot split times\n",
    "plt.figure(figsize=(12, 6))\n",
    "for i, swimmer in enumerate(valid_data['Swimmer']):\n",
    "    plt.plot([50, 100, 150, 200], \n",
    "             [valid_data.iloc[i]['Split_50m'], valid_data.iloc[i]['Split_100m'], \n",
    "              valid_data.iloc[i]['Split_150m'], valid_data.iloc[i]['Split_200m']], \n",
    "             'o-', label=swimmer)\n",
    "plt.title('Split Times by 50m Segment')\n",
    "plt.xlabel('Distance (m)')\n",
    "plt.ylabel('Split Time (seconds)')\n",
    "plt.grid(True)\n",
    "plt.legend()\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Analyze your custom race strategies\n",
    "if valid_data.shape[0] > 3:  # If you've added your own strategy\n",
    "    analyze_race_results(valid_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Day 1 Summary and Key Takeaways\n",
    "\n",
    "Today we've covered the fundamentals of swimming data analysis:\n",
    "\n",
    "1. **Key Performance Metrics**:\n",
    "   - Stroke rate, stroke length, velocity, and stroke index\n",
    "   - How these metrics interact and affect performance\n",
    "\n",
    "2. **Swimmer Profile Analysis**:\n",
    "   - Creating a database for tracking swimmer development\n",
    "   - Visualizing progress over time\n",
    "   - Identifying strengths and areas for improvement\n",
    "\n",
    "3. **Race Analysis**:\n",
    "   - Understanding pacing strategies\n",
    "   - Comparing split times\n",
    "   - Identifying optimal race distribution\n",
    "\n",
    "### Homework Assignment\n",
    "\n",
    "Before Day 2, please:\n",
    "1. Collect split times from one of your swimmers in a recent race\n",
    "2. Calculate their pacing strategy using the techniques shown today\n",
    "3. Identify one area where their race execution could be improved\n",
    "4. Be prepared to discuss your findings"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Day 2: Video Analysis and Stroke Mechanics\n",
    "\n",
    "On Day 2, we focus on using video analysis to quantify stroke mechanics and identify technical improvements."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.1 Basics of Video Analysis in Swimming\n",
    "\n",
    "Video analysis is a powerful tool for swimming coaches. In this section, we'll learn how to use Python and OpenCV to analyze swimming technique from video footage."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import necessary libraries for video analysis\n",
    "import cv2\n",
    "import numpy as np\n",
    "from IPython.display import HTML\n",
    "from base64 import b64encode\n",
    "import matplotlib.pyplot as plt\n",
    "import os\n",
    "\n",
    "# Function to display video in the notebook\n",
    "def show_video(video_path):\n",
    "    video_file = open(video_path, \"rb\")\n",
    "    video_bytes = video_file.read()\n",
    "    video_file.close()\n",
    "    video_b64 = b64encode(video_bytes).decode()\n",
    "    video_type = video_path.split('.')[-1]\n",
    "    \n",
    "    return HTML(f\"\"\"<video width=\"640\" height=\"480\" controls>\n",
    "                   <source src=\"data:video/{video_type};base64,{video_b64}\" type=\"video/{video_type}\">\n",
    "                   Your browser does not support the video tag.\n",
    "                </video>\"\"\")\n",
    "\n",
    "# Sample video analysis function\n",
    "def analyze_swimming_video(video_path, show_output=True):\n",
    "    \"\"\"Basic video analysis for swimming footage\"\"\"\n",
    "    \n",
    "    # Check if video file exists\n",
    "    if not os.path.exists(video_path):\n",
    "        print(f\"Error: Video file {video_path} not found.\")\n",
    "        print(\"Please download the sample video or use your own video file.\")\n",
    "        return\n",
    "    \n",
    "    # Open the video file\n",
    "    cap = cv2.VideoCapture(video_path)\n",
    "    \n",
    "    if not cap.isOpened():\n",
    "        print(\"Error opening video file\")\n",
    "        return\n",
    "    \n",
    "    # Get video properties\n",
    "    frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n",
    "    frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n",
    "    fps = cap.get(cv2.CAP_PROP_FPS)\n",
    "    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n",
    "    \n",
    "    print(f\"Video properties:\")\n",
    "    print(f\"  Dimensions: {frame_width}x{frame_height}\")\n",
    "    print(f\"  FPS: {fps}\")\n",
    "    print(f\"  Total frames: {frame_count}\")\n",
    "    print(f\"  Duration: {frame_count/fps:.1f} seconds\")\n",
    "    \n",
    "    # We'll just demonstrate some basic techniques here\n",
    "    # In a real analysis, you'd use more sophisticated techniques\n",
    "    \n",
    "    # For demonstration, let's extract frames at regular intervals\n",
    "    sample_frames = []\n",
    "    sample_interval = int(frame_count / 4)  # 4 frames across the video\n",
    "    \n",
    "    for i in range(4):\n",
    "        frame_idx = i * sample_interval\n",
    "        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_idx)\n",
    "        ret, frame = cap.read()\n",
    "        if ret:\n",
    "            # Convert from BGR to RGB for matplotlib\n",
    "            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n",
    "            sample_frames.append((frame_idx, frame_rgb))\n",
    "    \n",
    "    # Display the sample frames\n",
    "    if show_output and sample_frames:\n",
    "        fig, axes = plt.subplots(1, 4, figsize=(20, 5))\n",
    "        for i, (frame_idx, frame) in enumerate(sample_frames):\n",
    "            axes[i].imshow(frame)\n",
    "            axes[i].set_title(f\"Frame {frame_idx} ({frame_idx/fps:.1f}s)\")\n",
    "            axes[i].axis('off')\n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "    \n",
    "    # Close the video file\n",
    "    cap.release()\n",
    "    \n",
    "    return sample_frames\n",
    "\n",
    "# Note: You need to provide your own video file path\n",
    "# For example: analyze_swimming_video('path/to/your/swimming_video.mp4')\n",
    "# If you have sample videos, uncomment the following line\n",
    "# analyze_swimming_video('sample_freestyle.mp4')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Using Video Analysis to Calculate Stroke Parameters\n",
    "\n",
    "Now, let's see how we can use video analysis to calculate stroke rate, stroke count, and estimate stroke length."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_stroke_parameters_from_video(video_path, pool_length=25, known_distance=None):\n",
    "    \"\"\"Calculate stroke parameters from video analysis\n",
    "    \n",
    "    Parameters:\n",
    "    video_path (str): Path to the video file\n",
    "    pool_length (float): Length of the pool in meters\n",
    "    known_distance (float): If the video doesn't cover the whole pool, specify the distance covered\n",
    "    \n",
    "    Returns:\n",
    "    dict: Dictionary of calculated stroke parameters\n",
    "    \"\"\"\n",
    "    # Check if video file exists\n",
    "    if not os.path.exists(video_path):\n",
    "        print(f\"Error: Video file {video_path} not found.\")\n",
    "        return {}\n",
    "    \n",
    "    # Open the video file\n",
    "    cap = cv2.VideoCapture(video_path)\n",
    "    if not cap.isOpened():\n",
    "        print(\"Error opening video file\")\n",
    "        return {}\n",
    "    \n",
    "    # Get video properties\n",
    "    fps = cap.get(cv2.CAP_PROP_FPS)\n",
    "    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))\n",
    "    duration = frame_count / fps\n",
    "    \n",
    "    # In a real implementation, we would detect strokes automatically\n",
    "    # For this example, we'll simulate it with user input\n",
    "    print(f\"Video duration: {duration:.1f} seconds\")\n",
    "    \n",
    "    # Ask user for stroke count\n",
    "    stroke_count = input(\"Enter the number of stroke cycles observed in the video: \")\n",
    "    try:\n",
    "        stroke_count = int(stroke_count)\n",
    "    except ValueError:\n",
    "        print(\"Invalid input. Using default value of 10 strokes.\")\n",
    "        stroke_count = 10\n",
    "    \n",
    "    # Calculate the distance if not provided\n",
    "    distance = known_distance if known_distance else pool_length\n",
    "    \n",
    "    # Calculate parameters\n",
    "    velocity = distance / duration  # m/s\n",
    "    stroke_rate = (stroke_count / duration) * 60  # strokes per minute\n",
    "    stroke_length = distance / stroke_count  # meters per stroke\n",
    "    stroke_index = velocity * stroke_length  # efficiency measure\n",
    "    \n",
    "    # Formulate results\n",
    "    results = {\n",
    "        'distance': distance,\n",
    "        'duration': duration,\n",
    "        'stroke_count': stroke_count,\n",
    "        'velocity': velocity,\n",
    "        'stroke_rate': stroke_rate,\n",
    "        'stroke_length': stroke_length,\n",
    "        'stroke_index': stroke_index\n",
    "    }\n",
    "    \n",
    "    # Display results\n",
    "    print(\"\\nCalculated Parameters:\")\n",
    "    print(f\"Distance: {distance:.1f} meters\")\n",
    "    print(f\"Duration: {duration:.1f} seconds\")\n",
    "    print(f\"Stroke Count: {stroke_count} cycles\")\n",
    "    print(f\"Velocity: {velocity:.2f} m/s\")\n",
    "    print(f\"Stroke Rate: {stroke_rate:.1f} strokes/minute\")\n",
    "    print(f\"Stroke Length: {stroke_length:.2f} meters/stroke\")\n",
    "    print(f\"Stroke Index (Efficiency): {stroke_index:.2f}\")\n",
    "    \n",
    "    # Close the video file\n",
    "    cap.release()\n",
    "    \n",
    "    return results\n",
    "\n",
    "# Note: You need to provide your own video file path\n",
    "# For example: calculate_stroke_parameters_from_video('path/to/your/swimming_video.mp4')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.2 Advanced Stroke Analysis Techniques\n",
    "\n",
    "For a more detailed analysis, we can track specific points on the swimmer's body to analyze stroke mechanics in detail."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Note: This is a simplified version of stroke analysis\n",
    "# Advanced implementations would use computer vision techniques like pose estimation\n",
    "\n",
    "# Sample data: Hand positions tracked over multiple frames\n",
    "# In reality, this would come from sophisticated tracking algorithms\n",
    "# Format: frame_number, x_position, y_position (origin at top-left)\n",
    "right_hand_tracking = [\n",
    "    # Entry phase\n",
    "    (1, 100, 150),\n",
    "    (5, 110, 180),\n",
    "    # Catch phase\n",
    "    (10, 120, 200),\n",
    "    (15, 130, 210),\n",
    "    # Pull phase\n",
    "    (20, 150, 200),\n",
    "    (25, 170, 190),\n",
    "    (30, 190, 170),\n",
    "    # Recovery phase\n",
    "    (35, 170, 150),\n",
    "    (40, 150, 130),\n",
    "    (45, 130, 120),\n",
    "    (50, 100, 150)  # Back to entry\n",
    "]\n",
    "\n",
    "# Convert to numpy arrays for easier processing\n",
    "right_hand_data = np.array(right_hand_tracking)\n",
    "\n",
    "# Visualize the hand path\n",
    "plt.figure(figsize=(10, 6))\n",
    "plt.plot(right_hand_data[:, 1], right_hand_data[:, 2], 'o-', linewidth=2, markersize=8)\n",
    "\n",
    "# Mark different phases of the stroke with different colors\n",
    "plt.plot(right_hand_data[0:2, 1], right_hand_data[0:2, 2], 'g-', linewidth=3, label='Entry')\n",
    "plt.plot(right_hand_data[2:4, 1], right_hand_data[2:4, 2], 'b-', linewidth=3, label='Catch')\n",
    "plt.plot(right_hand_data[4:7, 1], right_hand_data[4:7, 2], 'r-', linewidth=3, label='Pull')\n",
    "plt.plot(right_hand_data[7:, 1], right_hand_data[7:, 2], 'y-', linewidth=3, label='Recovery')\n",
    "\n",
    "# Add annotations\n",
    "plt.annotate('Entry', (right_hand_data[0, 1], right_hand_data[0, 2]), \n",
    "             xytext=(80, 130), arrowprops=dict(facecolor='green', shrink=0.05))\n",
    "plt.annotate('Catch', (right_hand_data[3, 1], right_hand_data[3, 2]), \n",
    "             xytext=(150, 230), arrowprops=dict(facecolor='blue', shrink=0.05))\n",
    "plt.annotate('Pull', (right_hand_data[5, 1], right_hand_data[5, 2]), \n",
    "             xytext=(200, 190), arrowprops=dict(facecolor='red', shrink=0.05))\n",
    "plt.annotate('Recovery', (right_hand_data[8, 1], right_hand_data[8, 2]), \n",
    "             xytext=(120, 100), arrowprops=dict(facecolor='yellow', shrink=0.05))\n",
    "\n",
    "# Setting the y-axis direction to be from top to bottom (like image coordinates)\n",
    "plt.gca().invert_yaxis()\n",
    "\n",
    "plt.title('Right Hand Path During Freestyle Stroke Cycle')\n",
    "plt.xlabel('X Position (pixels)')\n",
    "plt.ylabel('Y Position (pixels)')\n",
    "plt.grid(True)\n",
    "plt.legend(loc='upper right')\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Calculate stroke efficiency metrics based on hand path\n",
    "def analyze_hand_path(hand_data):\n",
    "    # Calculate total distance traveled\n",
    "    total_distance = 0\n",
    "    for i in range(1, len(hand_data)):\n",
    "        dx = hand_data[i, 1] - hand_data[i-1, 1]\n",
    "        dy = hand_data[i, 2] - hand_data[i-1, 2]\n",
    "        segment_distance = np.sqrt(dx**2 + dy**2)\n",
    "        total_distance += segment_distance\n",
    "    \n",
    "    # Calculate forward distance (x-direction only)\n",
    "    forward_distance = abs(max(hand_data[:, 1]) - min(hand_data[:, 1]))\n",
    "    \n",
    "    # Calculate vertical distance (y-direction only)\n",
    "    vertical_distance = abs(max(hand_data[:, 2]) - min(hand_data[:, 2]))\n",
    "    \n",
    "    # Calculate path efficiency ratio\n",
    "    # Lower values mean more direct path\n",
    "    path_efficiency = total_distance / forward_distance\n",
    "    \n",
    "    return {\n",
    "        'total_distance': total_distance,\n",
    "        'forward_distance': forward_distance,\n",
    "        'vertical_distance': vertical_distance,\n",
    "        'path_efficiency': path_efficiency\n",
    "    }\n",
    "\n",
    "# Analyze the hand path\n",
    "hand_path_metrics = analyze_hand_path(right_hand_data)\n",
    "print(\"Hand Path Analysis:\")\n",
    "print(f\"Total hand path distance: {hand_path_metrics['total_distance']:.1f} pixels\")\n",
    "print(f\"Forward distance: {hand_path_metrics['forward_distance']:.1f} pixels\")\n",
    "print(f\"Vertical distance: {hand_path_metrics['vertical_distance']:.1f} pixels\")\n",
    "print(f\"Path efficiency ratio: {hand_path_metrics['path_efficiency']:.2f} (lower is more direct)\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Comparing Stroke Mechanics Between Swimmers\n",
    "\n",
    "Now, let's compare stroke mechanics between different swimmers or between a swimmer and an ideal model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Sample data: Hand paths for different swimmers\n",
    "elite_swimmer = np.array([\n",
    "    (1, 100, 150),\n",
    "    (5, 110, 170),\n",
    "    (10, 120, 190),\n",
    "    (15, 135, 200),\n",
    "    (20, 160, 195),\n",
    "    (25, 185, 175),\n",
    "    (30, 190, 160),\n",
    "    (35, 170, 145),\n",
    "    (40, 140, 135),\n",
    "    (45, 120, 140),\n",
    "    (50, 100, 150)\n",
    "])\n",
    "\n",
    "novice_swimmer = np.array([\n",
    "    (1, 100, 150),\n",
    "    (5, 105, 180),\n",
    "    (10, 110, 210),\n",
    "    (15, 120, 230),\n",
    "    (20, 140, 220),\n",
    "    (25, 160, 200),\n",
    "    (30, 180, 190),\n",
    "    (35, 170, 170),\n",
    "    (40, 150, 160),\n",
    "    (45, 130, 155),\n",
    "    (50, 100, 150)\n",
    "])\n",
    "\n",
    "# Visualize comparison\n",
    "plt.figure(figsize=(12, 6))\n",
    "plt.plot(elite_swimmer[:, 1], elite_swimmer[:, 2], 'b-', linewidth=2, label='Elite Swimmer')\n",
    "plt.plot(novice_swimmer[:, 1], novice_swimmer[:, 2], 'r-', linewidth=2, label='Novice Swimmer')\n",
    "\n",
    "# Mark entry and mid-pull points\n",
    "plt.plot(elite_swimmer[0, 1], elite_swimmer[0, 2], 'bo', markersize=8, label='Elite Entry')\n",
    "plt.plot(elite_swimmer[4, 1], elite_swimmer[4, 2], 'bD', markersize=8, label='Elite Mid-Pull')\n",
    "plt.plot(novice_swimmer[0, 1], novice_swimmer[0, 2], 'ro', markersize=8, label='Novice Entry')\n",
    "plt.plot(novice_swimmer[4, 1], novice_swimmer[4, 2], 'rD', markersize=8, label='Novice Mid-Pull')\n",
    "\n",
    "# Setting the y-axis direction to be from top to bottom (like image coordinates)\n",
    "plt.gca().invert_yaxis()\n",
    "\n",
    "plt.title('Hand Path Comparison: Elite vs Novice Swimmer')\n",
    "plt.xlabel('X Position (pixels)')\n",
    "plt.ylabel('Y Position (pixels)')\n",
    "plt.grid(True)\n",
    "plt.legend(loc='upper right')\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Compare the path metrics\n",
    "elite_metrics = analyze_hand_path(elite_swimmer)\n",
    "novice_metrics = analyze_hand_path(novice_swimmer)\n",
    "\n",
    "metrics_comparison = pd.DataFrame({\n",
    "    'Metric': ['Total Path Distance', 'Forward Distance', 'Vertical Distance', 'Path Efficiency'],\n",
    "    'Elite Swimmer': [elite_metrics['total_distance'], elite_metrics['forward_distance'], \n",
    "                      elite_metrics['vertical_distance'], elite_metrics['path_efficiency']],\n",
    "    'Novice Swimmer': [novice_metrics['total_distance'], novice_metrics['forward_distance'], \n",
    "                       novice_metrics['vertical_distance'], novice_metrics['path_efficiency']],\n",
    "})\n",
    "\n",
    "metrics_comparison['Difference (%)'] = ((metrics_comparison['Novice Swimmer'] - metrics_comparison['Elite Swimmer']) / \n",
    "                                       metrics_comparison['Elite Swimmer'] * 100).round(1)\n",
    "\n",
    "metrics_comparison"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2.3 Stroke Timing and Rhythm Analysis\n",
    "\n",
    "Timing and rhythm are critical in swimming performance. Let's analyze stroke timing and rhythmic patterns."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Sample data: Stroke timings for different swimmers\n",
    "# Format: Timestamp of key stroke events in seconds\n",
    "swimmer_data = pd.DataFrame({\n",
    "    'Swimmer': ['Elite 1', 'Elite 2', 'Age Group 1', 'Age Group 2'],\n",
    "    'Stroke': ['Freestyle', 'Freestyle', 'Freestyle', 'Freestyle'],\n",
    "    'Events': [\n",
    "        # Elite swimmer 1: Very consistent timing\n",
    "        [0.0, 1.2, 2.4, 3.6, 4.8, 6.0, 7.2, 8.4, 9.6, 10.8],\n",
    "        # Elite swimmer 2: Slight variation but consistent\n",
    "        [0.0, 1.3, 2.5, 3   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise: Create Your Own Pacing Strategy Analysis\n",
    "\n",
    "Now it's your turn to analyze real or hypothetical race data. Create a pacing strategy for a 200m race based on different swimming event types (e.g., freestyle, butterfly, individual medley) and swimmer types (e.g., sprinter, distance swimmer). What would be the ideal pacing strategy for each?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Exercise template\n",
    "\n",
    "# Create a custom race strategy for different event types\n",
    "custom_race_data = pd.DataFrame({\n",
    "    'Swimmer': ['Sprinter', 'Distance', 'Balanced', 'Your Strategy'],\n",
    "    'Event': ['200 Free', '200 Free', '200 Free', '200 Free'],\n",
    "    'Split_50m': [24.5, 26.0, 25.5, 0.0],  # First 50m split in seconds\n",
    "    'Split_100m': [26{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Swimming Coach Technical Training\n",
    "## 3-Day Technical Analysis Workshop\n",
    "\n",
    "This notebook provides swimming coaches with tools to analyze, visualize, and improve swimmer performance using data-driven approaches. The workshop is structured over three days, covering fundamental concepts to advanced analytics."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Setting Up Your Environment\n",
    "\n",
    "Before we begin, we need to set up our Conda environment with the necessary packages. Run these commands in your terminal:\n",
    "\n",
    "```bash\n",
    "# Create a new conda environment\n",
    "conda create -n swimcoach python=3.9\n",
    "\n",
    "# Activate the environment\n",
    "conda activate swimcoach\n",
    "\n",
    "# Install required packages\n",
    "conda install -c conda-forge jupyter numpy pandas matplotlib seaborn opencv scikit-learn\n",
    "conda install -c conda-forge dash plotly\n",
    "pip install moviepy\n",
    "```\n",
    "\n",
    "Once installed, you can start Jupyter Notebook with:\n",
    "```bash\n",
    "jupyter notebook\n",
    "```\n",
    "\n",
    "Let's confirm our environment is set up correctly:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Check installed packages and versions\n",
    "import sys\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import cv2\n",
    "import sklearn\n",
    "import plotly.express as px\n",
    "import dash\n",
    "\n",
    "print(f\"Python version: {sys.version}\")\n",
    "print(f\"NumPy version: {np.__version__}\")\n",
    "print(f\"Pandas version: {pd.__version__}\")\n",
    "print(f\"Matplotlib version: {plt.__version__}\")\n",
    "print(f\"OpenCV version: {cv2.__version__}\")\n",
    "print(f\"Scikit-learn version: {sklearn.__version__}\")\n",
    "print(f\"Plotly version: {px.__version__}\")\n",
    "\n",
    "# Set default plotting style\n",
    "sns.set_style(\"whitegrid\")\n",
    "plt.rcParams['figure.figsize'] = [12, 8]\n",
    "plt.rcParams['font.size'] = 14"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Day 1: Fundamentals of Swimming Data Analysis\n",
    "\n",
    "## 1.1 Introduction to Swimming Analytics\n",
    "\n",
    "Swimming coaches traditionally rely on subjective observations, but data-driven approaches can provide objective insights that complement experienced coaching eyes. Today we'll start learning how to collect, analyze, and interpret swimming data."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Key Performance Indicators in Swimming\n",
    "\n",
    "Let's examine the primary metrics used to analyze swimming performance:\n",
    "\n",
    "- **Stroke Rate (SR)**: Number of stroke cycles per minute\n",
    "- **Stroke Length (SL)**: Distance traveled per stroke cycle\n",
    "- **Stroke Index (SI)**: Product of velocity and stroke length\n",
    "- **Split Times**: Time taken for each segment of a race\n",
    "- **Velocity**: Speed of the swimmer\n",
    "- **Stroke Count**: Number of strokes taken per length\n",
    "- **Stroke Efficiency**: How effectively energy is converted to forward motion\n",
    "\n",
    "Let's create a function to calculate these metrics:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calculate_swimming_metrics(distance, time, stroke_count):\n",
    "    \"\"\"\n",
    "    Calculate key swimming performance metrics\n",
    "    \n",
    "    Parameters:\n",
    "    distance (float): Distance swum in meters\n",
    "    time (float): Time taken in seconds\n",
    "    stroke_count (int): Number of complete stroke cycles\n",
    "    \n",
    "    Returns:\n",
    "    dict: Dictionary of calculated metrics\n",
    "    \"\"\"\n",
    "    # Average velocity\n",
    "    velocity = distance / time  # m/s\n",
    "    \n",
    "    # Stroke length\n",
    "    stroke_length = distance / stroke_count  # meters per stroke\n",
    "    \n",
    "    # Stroke rate\n",
    "    stroke_rate = (stroke_count / time) * 60  # strokes per minute\n",
    "    \n",
    "    # Stroke index (measure of efficiency)\n",
    "    stroke_index = velocity * stroke_length\n",
    "    \n",
    "    return {\n",
    "        'velocity': velocity,\n",
    "        'stroke_length': stroke_length,\n",
    "        'stroke_rate': stroke_rate,\n",
    "        'stroke_index': stroke_index\n",
    "    }\n",
    "\n",
    "# Example: Swimmer completes 50m freestyle in 30 seconds with 30 strokes\n",
    "metrics = calculate_swimming_metrics(50, 30, 30)\n",
    "for key, value in metrics.items():\n",
    "    print(f\"{key.replace('_', ' ').title()}: {value:.2f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Sample Data: Elite Swimmers\n",
    "\n",
    "Let's analyze data from elite swimmers to understand benchmark performance metrics:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Sample data for 100m freestyle elite swimmers\n",
    "elite_swimmers = pd.DataFrame({\n",
    "    'Name': ['Dressel', 'Chalmers', 'Kolesnikov', 'Miressi', 'Nemeth'],\n",
    "    'Time_50m': [22.39, 22.49, 22.97, 22.79, 22.84],  # First 50m split in seconds\n",
    "    'Time_100m': [47.02, 47.08, 47.44, 47.45, 47.51],  # Final time in seconds\n",
    "    'Stroke_Count_50m': [34, 38, 36, 42, 40],  # Strokes for first 50m\n",
    "    'Height_cm': [191, 193, 195, 200, 188],  # Height in cm\n",
    "    'Gender': ['M', 'M', 'M', 'M', 'M']\n",
    "})\n",
    "\n",
    "# Calculate second 50m split\n",
    "elite_swimmers['Time_Second50m'] = elite_swimmers['Time_100m'] - elite_swimmers['Time_50m']\n",
    "\n",
    "# Calculate velocity for each 50m\n",
    "elite_swimmers['Velocity_First50m'] = 50 / elite_swimmers['Time_50m']\n",
    "elite_swimmers['Velocity_Second50m'] = 50 / elite_swimmers['Time_Second50m']\n",
    "\n",
    "# Calculate stroke length\n",
    "elite_swimmers['Stroke_Length'] = 50 / elite_swimmers['Stroke_Count_50m']\n",
    "\n",
    "# Calculate stroke rate (strokes per minute)\n",
    "elite_swimmers['Stroke_Rate'] = (elite_swimmers['Stroke_Count_50m'] / elite_swimmers['Time_50m']) * 60\n",
    "\n",
    "# Calculate stroke index\n",
    "elite_swimmers['Stroke_Index'] = elite_swimmers['Velocity_First50m'] * elite_swimmers['Stroke_Length']\n",
    "\n",
    "elite_swimmers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now let's visualize this data to better understand the relationship between these metrics:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Relationship between stroke length and race time\n",
    "plt.figure(figsize=(10, 6))\n",
    "sns.scatterplot(x='Stroke_Length', y='Time_100m', data=elite_swimmers, s=100)\n",
    "\n",
    "for i, row in elite_swimmers.iterrows():\n",
    "    plt.text(row['Stroke_Length']+0.01, row['Time_100m']+0.01, row['Name'])\n",
    "    \n",
    "plt.title('Relationship Between Stroke Length and 100m Time')\n",
    "plt.xlabel('Stroke Length (meters)')\n",
    "plt.ylabel('100m Time (seconds)')\n",
    "plt.grid(True)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Relationship between stroke rate and stroke length\n",
    "plt.figure(figsize=(10, 6))\n",
    "sns.scatterplot(x='Stroke_Rate', y='Stroke_Length', data=elite_swimmers, s=100)\n",
    "\n",
    "for i, row in elite_swimmers.iterrows():\n",
    "    plt.text(row['Stroke_Rate']+0.1, row['Stroke_Length']+0.01, row['Name'])\n",
    "    \n",
    "plt.title('Stroke Rate vs. Stroke Length')\n",
    "plt.xlabel('Stroke Rate (strokes per minute)')\n",
    "plt.ylabel('Stroke Length (meters)')\n",
    "plt.grid(True)\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Race pacing: First 50m vs Second 50m\n",
    "plt.figure(figsize=(10, 6))\n",
    "x = range(len(elite_swimmers))\n",
    "width = 0.35\n",
    "\n",
    "plt.bar(x, elite_swimmers['Time_50m'], width, label='First 50m')\n",
    "plt.bar([i + width for i in x], elite_swimmers['Time_Second50m'], width, label='Second 50m')\n",
    "\n",
    "plt.xlabel('Swimmer')\n",
    "plt.ylabel('Split Time (seconds)')\n",
    "plt.title('Race Pacing: Split Comparison')\n",
    "plt.xticks([i + width/2 for i in x], elite_swimmers['Name'])\n",
    "plt.legend()\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1.2 Creating a Swimmer Profile Database\n",
    "\n",
    "Now, let's create a database structure to track your swimmers' progress over time. This will help identify trends and areas for improvement."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a sample swimmer database\n",
    "def create_swimmer_database():\n",
    "    # Demographic information\n",
    "    swimmers = pd.DataFrame({\n",
    "        'SwimmerID': range(1, 11),\n",
    "        'Name': ['Alex Johnson', 'Maria Garcia', 'Sam Lee', 'Taylor Smith', 'Jordan Brown',\n",
    "                'Casey Martinez', 'Dakota Wilson', 'Riley Thomas', 'Cameron White', 'Avery Jackson'],\n",
    "        'Age': [16, 15, 17, 14, 18, 16, 15, 17, 14, 16],\n",
    "        'Gender': ['M', 'F', 'M', 'F', 'M', 'F', 'M', 'F', 'M', 'F'],\n",
    "        'Height_cm': [175, 165, 180, 160, 185, 170, 178, 163, 172, 168],\n",
    "        'Years_Experience': [5, 8, 6, 4, 10, 7, 5, 9, 3, 6]\n",
    "    })\n",
    "    \n",
    "    # Create performance tracking database with multiple time points\n",
    "    # Let's track 100m freestyle times over 4 assessment periods\n",
    "    np.random.seed(42)  # For reproducibility\n",
    "    \n",
    "    all_records = []\n",
    "    \n",
    "    for swimmer_id in swimmers['SwimmerID']:\n",
    "        # Base performance level - faster swimmers have lower baseline time\n",
    "        base_time = 60 + np.random.normal(0, 5)  # Around 1 minute base time with some variation\n",
    "        \n",
    "        # Improvement trajectory - most swimmers improve over time with some variation\n",
    "        for assessment_id in range(1, 5):  # 4 assessment periods\n",
    "            # On average, swimmers improve by 0.5 seconds per assessment\n",
    "            improvement = np.random.normal(0.5, 0.3) * assessment_id\n",
    "            \n",
    "            # Final time with some random variation\n",
    "            time = base_time - improvement + np.random.normal(0, 1)\n",
    "            \n",
    "            # Add some realistic stroke data\n",
    "            stroke_count = int(32 + np.random.normal(0, 2))  # Around 32 strokes\n",
    "            \n",
    "            # Calculate metrics\n",
    "            metrics = calculate_swimming_metrics(100, time, stroke_count)\n",
    "            \n",
    "            # Record\n",
    "            record = {\n",
    "                'SwimmerID': swimmer_id,\n",
    "                'AssessmentID': assessment_id,\n",
    "                'Date': f'2024-{3+assessment_id}-01',  # Quarterly assessments\n",
    "                'Event': '100m Freestyle',\n",
    "                'Time': time,\n",
    "                'Stroke_Count': stroke_count,\n",
    "                'Velocity': metrics['velocity'],\n",
    "                'Stroke_Length': metrics['stroke_length'],\n",
    "                'Stroke_Rate': metrics['stroke_rate'],\n",
    "                'Stroke_Index': metrics['stroke_index']\n",
    "            }\n",
    "            \n",
    "            all_records.append(record)\n",
    "    \n",
    "    performances = pd.DataFrame(all_records)\n",
    "    \n",
    "    return swimmers, performances\n",
    "\n",
    "# Create the database\n",
    "swimmers_db, performances_db = create_swimmer_database()\n",
    "\n",
    "# Display the first few entries\n",
    "print(\"Swimmers Database:\")\n",
    "display(swimmers_db.head())\n",
    "\n",
    "print(\"\\nPerformances Database:\")\n",
    "display(performances_db.head())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Analyzing Performance Trends\n",
    "\n",
    "Now, let's analyze the performance trends of these swimmers over time:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Merge databases to get swimmer names\n",
    "merged_data = pd.merge(performances_db, swimmers_db[['SwimmerID', 'Name', 'Age', 'Gender']], on='SwimmerID')\n",
    "\n",
    "# Plot time improvements for each swimmer\n",
    "plt.figure(figsize=(12, 6))\n",
    "for swimmer_id, name in zip(swimmers_db['SwimmerID'], swimmers_db['Name']):\n",
    "    swimmer_data = merged_data[merged_data['SwimmerID'] == swimmer_id]\n",
    "    plt.plot(swimmer_data['AssessmentID'], swimmer_data['Time'], marker='o', label=name)\n",
    "\n",
    "plt.title('100m Freestyle Time Progression')\n",
    "plt.xlabel('Assessment Period')\n",
    "plt.ylabel('Time (seconds)')\n",
    "plt.grid(True)\n",
    "plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# Calculate improvement percentage\n",
    "improvement_df = pd.DataFrame()\n",
    "\n",
    "for swimmer_id in swimmers_db['SwimmerID']:\n",
    "    swimmer_data = merged_data[merged_data['SwimmerID'] == swimmer_id].sort_values('AssessmentID')\n",
    "    initial_time = swimmer_data.iloc[0]['Time']\n",
    "    final_time = swimmer_data.iloc[-1]['Time']\n",
    "    \n",
    "    improvement_percent = ((initial_time - final_time) / initial_time) * 100\n",
    "    \n",
    "    improvement_df = improvement_df.append({\n",
    "        'SwimmerID': swimmer_id,\n",
    "        'Name': swimmer_data.iloc[0]['Name'],\n",
    "        'Initial_Time': initial_time,\n",
    "        'Final_Time': final_time,\n",
    "        'Improvement_Percent': improvement_percent\n",
    "    }, ignore_index=True)\n",
    "\n",
    "# Sort by improvement percentage\n",
    "improvement_df = improvement_df.sort_values('Improvement_Percent', ascending=False)\n",
    "\n",
    "# Plot improvement percentage\n",
    "plt.figure(figsize=(12, 6))\n",
    "bars = plt.bar(improvement_df['Name'], improvement_df['Improvement_Percent'])\n",
    "plt.title('Improvement Percentage Over Assessment Period')\n",
    "plt.xlabel('Swimmer')\n",
    "plt.ylabel('Improvement (%)')\n",
    "plt.xticks(rotation=45, ha='right')\n",
    "plt.grid(axis='y')\n",
    "\n",
    "# Add data labels\n",
    "for bar in bars:\n",
    "    height = bar.get_height()\n",
    "    plt.text(bar.get_x() + bar.get_width()/2., height + 0.1,\n",
    "            f'{height:.1f}%', ha='center', va='bottom')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercise: Analyzing Individual Swimmers\n",
    "\n",
    "Now it's your turn! Select a swimmer and perform a detailed analysis of their metrics over time."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Function to analyze an individual swimmer\n",
    "def analyze_swimmer(swimmer_id):\n",
    "    # Get swimmer info\n",
    "    swimmer_info = swimmers_db[swimmers_db['SwimmerID'] == swimmer_id].iloc[0]\n",
    "    \n",
    "    # Get performance data\n",
    "    performance_data = performances_db[performances_db['SwimmerID'] == swimmer_id].sort_values('AssessmentID')\n",
    "    \n",
    "    # Print basic information\n",
    "    print(f\"Swimmer Profile: {swimmer_info['Name']}\")\n",
    "    print(f\"Age: {swimmer_info['Age']}\")\n",
    "    print(f\"Gender: {'Male' if swimmer_info['Gender'] == 'M' else 'Female'}\")\n",
    "    print(f\"Height: {swimmer_info['Height_cm']} cm\")\n",
    "    print(f\"Years of Experience: {swimmer_info['Years_Experience']}\")\n",
    "    print(\"\\n\")\n",
    "    \n",
    "    # Performance table\n",
    "    display(performance_data[['AssessmentID', 'Date', 'Time', 'Stroke_Count', 'Velocity', \n",
    "                           'Stroke_Length', 'Stroke_Rate', 'Stroke_Index']])\n",
    "    \n",
    "    # Plot performance metrics over time\n",
    "    fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
    "    \n",
    "    # Time progression\n",
    "    axes[0, 0].plot(performance_data['AssessmentID'], performance_data['Time'], 'o-', color='blue')\n",
    "    axes[0, 0].set_title('Time Progression')\n",
    "    axes[0, 0].set_xlabel('Assessment Period')\n",
    "    axes[0, 0].set_ylabel('Time (seconds)')\n",
    "    axes[0, 0].grid(True)\n",
    "    \n",
    "    # Stroke length\n",
    "    axes[0, 1].plot(performance_data['AssessmentID'], performance_data['Stroke_Length'], 'o-', color='green')\n",
    "    axes[0, 1].set_title('Stroke Length Progression')\n",
    "    axes[0, 1].set_xlabel('Assessment Period')\n",
    "    axes[0, 1].set_ylabel('Stroke Length (meters)')\n",
    "    axes[0, 1].grid(True)\n",
    "    \n",
    "    # Stroke rate\n",
    "    axes[1, 0].plot(performance_data['AssessmentID'], performance_data['Stroke_Rate'], 'o-', color='orange')\n",
    "    axes[1, 0].set_title('Stroke Rate Progression')\n",
    "    axes[1, 0].set_xlabel('Assessment Period')\n",
    "    axes[1, 0].set_ylabel('Stroke Rate (strokes/min)')\n",
    "    axes[1, 0].grid(True)\n",
    "    \n",
    "    # Stroke index (efficiency)\n",
    "    axes[1, 1].plot(performance_data['AssessmentID'], performance_data['Stroke_Index'], 'o-', color='purple')\n",
    "    axes[1, 1].set_title('Stroke Index Progression (Efficiency)')\n",
    "    axes[1, 1].set_xlabel('Assessment Period')\n",
    "    axes[1, 1].set_ylabel('Stroke Index')\n",
    "    axes[1, 1].grid(True)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Provide coaching insights\n",
    "    initial = performance_data.iloc[0]\n",
    "    final = performance_data.iloc[-1]\n",
    "    \n",
    "    print(\"\\nCoaching Insights:\")\n",
    "    print(f\"Time Improvement: {initial['Time'] - final['Time']:.2f} seconds ({((initial['Time'] - final['Time'])/initial['Time']*100):.1f}%)\")\n",
    "    print(f\"Velocity Change: {final['Velocity'] - initial['Velocity']:.2f} m/s ({((final['Velocity'] - initial['Velocity'])/initial['Velocity']*100):.1f}%)\")\n",
    "    print(f\"Stroke Length Change: {final['Stroke_Length'] - initial['Stroke_Length']:.2f} m ({((final['Stroke_Length'] - initial['Stroke_Length'])/initial['Stroke_Length']*100):.1f}%)\")\n",
    "    print(f\"Stroke Rate Change: {final['Stroke_Rate'] - initial['Stroke_Rate']:.2f} strokes/min ({((final['Stroke_Rate'] - initial['Stroke_Rate'])/initial['Stroke_Rate']*100):.1f}%)\")\n",
    "    print(f\"Efficiency (Stroke Index) Change: {final['Stroke_Index'] - initial['Stroke_Index']:.2f} ({((final['Stroke_Index'] - initial['Stroke_Index'])/initial['Stroke_Index']*100):.1f}%)\")\n",
    "    \n",
    "    # Provide technique recommendations based on metrics\n",
    "    print(\"\\nTechnique Recommendations:\")\n",
    "    if final['Stroke_Length'] < 3.1:  # Arbitrary threshold\n",
    "        print(\"- Focus on increasing stroke length through better body position and catch phase\")\n",
    "    \n",
    "    if final['Stroke_Rate'] < 55:  # Arbitrary threshold\n",
    "        print(\"- Work on increasing stroke rate while maintaining stroke length\")\n",
    "        \n",
    "    if final['Stroke_Length'] > initial['Stroke_Length'] and final['Stroke_Rate'] < initial['Stroke_Rate']:\n",
    "        print(\"- Swimmer has increased efficiency but could work on power to increase stroke rate\")\n",
    "        \n",
    "    if final['Stroke_Length'] < initial['Stroke_Length'] and final['Stroke_Rate'] > initial['Stroke_Rate']:\n",
    "        print(\"- Swimmer has increased turnover but at the cost of stroke length; focus on maintaining distance per stroke\")\n",
    "\n",
    "# Example: Analyze swimmer with ID 1 (change this to analyze different swimmers)\n",
    "analyze_swimmer(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1.3 Race Analysis: Split Times and Pacing\n",
    "\n",
    "Understanding race pacing is crucial for optimal performance. Let's analyze some race splits and pacing strategies."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Sample race data (200m freestyle)\n",
    "race_data = pd.DataFrame({\n",
    "    'Swimmer': ['Swimmer A', 'Swimmer B', 'Swimmer C', 'Swimmer D', 'Swimmer E'],\n",
    "    'Split_50m': [26.5, 25.8, 26.2, 25.5, 26.8],\n",
    "    'Split_100m': [29.1, 28.4, 27.9, 28.7, 28.2],\n",
    "    'Split_150m': [30.2, 29.8, 29.5, 30.9, 29.7],\n",
    "    'Split_200m': [30.8, 31.5, 30.7, 32.4, 31.1],\n",
    "})\n",
    "\n",
    "# Calculate cumulative times\n",
    "race_data['Time_50m'] = race_data['Split_50m']\n",
    "race_data['Time_100m'] = race_data['Split_50m'] + race_data['Split_100m']\n",
    "race_data['Time_150m'] = race_data['Split_50m'] + race_data['Split_100m'] + race_data['Split_150m']\n",
    "race_data['Time_200m'] = race_data['Split_50m'] + race_data['Split_100m'] + race_data['Split_150m'] + race_data['Split_200m']\n",
    "\n",
    "# Calculate pacing (normalized to first 50m)\n",
    "race_data['Pace_50m'] = 1.0  # First 50 is the reference\n",
    "race_data['Pace_100m'] = race_data['Split_100m'] / race_data['Split_50m']\n",
    "race_data['Pace_150m'] = race_data['Split_150m'] / race_data['Split_50m']\n",
    "race_data['Pace_200m'] = race_data['Split_200m'] / race_data['Split_50m']\n",
    "\n",
    "# Display the data\n",
    "race_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize the race
# Plot split times
plt.figure(figsize=(12, 6))
for i, swimmer in enumerate(race_data['Swimmer']):
    plt.plot([50, 100, 150, 200], 
             [race_data.loc[i, 'Split_50m'], race_data.loc[i, 'Split_100m'], 
              race_data.loc[i, 'Split_150m'], race_data.loc[i, 'Split_200m']], 
             'o-', label=swimmer)
plt.title('Split Times by 50m Segment')
plt.xlabel('Distance (m)')
plt.ylabel('Split Time (seconds)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Plot cumulative race times
plt.figure(figsize=(12, 6))
for i, swimmer in enumerate(race_data['Swimmer']):
    plt.plot([50, 100, 150, 200], 
             [race_data.loc[i, 'Time_50m'], race_data.loc[i, 'Time_100m'], 
              race_data.loc[i, 'Time_150m'], race_data.loc[i, 'Time_200m']], 
             'o-', label=swimmer)
plt.title('Cumulative Race Time')
plt.xlabel('Distance (m)')
plt.ylabel('Cumulative Time (seconds)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Pace analysis
plt.figure(figsize=(12, 6))
for i, swimmer in enumerate(race_data['Swimmer']):
    plt.plot([50, 100, 150, 200], 
             [race_data.loc[i, 'Pace_50m'], race_data.loc[i, 'Pace_100m'], 
              race_data.loc[i, 'Pace_150m'], race_data.loc[i, 'Pace_200m']], 
             'o-', label=swimmer)
plt.axhline(y=1.0, color='r', linestyle='--', alpha=0.3, label='Even Pace')
plt.title('Pacing Strategy (Normalized to First 50m)')
plt.xlabel('Distance (m)')
plt.ylabel('Pace Ratio (compared to first 50m)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Analyze race results and pacing strategies
def analyze_race_results(race_data):
    # Sort by final time to get places
    sorted_data = race_data.sort_values('Time_200m')
    
    print("Final Results:")
    for i, (idx, row) in enumerate(sorted_data.iterrows()):
        print(f"{i+1}. {row['Swimmer']}: {row['Time_200m']:.2f} seconds")
    
    print("\nPacing Analysis:")
    for idx, row in sorted_data.iterrows():
        # Calculate pacing strategy
        pacing_strategy = ""
        if row['Split_50m'] < row['Split_100m'] < row['Split_150m'] < row['Split_200m']:
            pacing_strategy = "Progressive Slowdown"
        elif row['Split_50m'] > row['Split_100m'] > row['Split_150m'] > row['Split_200m']:
            pacing_strategy = "Negative Split (Getting Faster)"
        elif row['Split_50m'] < row['Split_100m'] and row['Split_150m'] < row['Split_200m']:
            pacing_strategy = "Fast Out, Fast Finish"
        else:
            pacing_strategy = "Mixed Strategy"
        
        # Calculate deviation from even pacing
        even_split = row['Time_200m'] / 4
        deviation = np.std([row['Split_50m'], row['Split_100m'], row['Split_150m'], row['Split_200m']]) / even_split * 100
        
        print(f"{row['Swimmer']}:")
        print(f"  Strategy: {pacing_strategy}")
        print(f"  Pacing Deviation: {deviation:.1f}% from even pacing")
        print(f"  First 100m vs Second 100m: {row['Split_50m'] + row['Split_100m']:.2f}s vs {row['Split_150m'] + row['Split_200m']:.2f}s")
        print()

# Run the analysis
analyze_race_results(race_data)